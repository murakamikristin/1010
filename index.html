<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#F4F1EB" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
<link rel="manifest" href="manifest.webmanifest" />
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
<title>1010 â€” Minimal</title>
<style>
  :root{
    --bg:#F4F1EB;
    --board:var(--bg);
    --tile:#FFFFFF;
    --block:#57606A;
    --text:#8A8172;
    --shadow:0 14px 45px rgba(39,36,29,.12);
    --max-width:520px;
    --board-size:520px;
    --cell-radius:8px;
    --pip-radius:6px;
    --grid-gap:8px;
  }
  @media (max-height: 760px){
    body{ gap:clamp(12px,3vh,18px); padding-top:16px; padding-bottom:16px; }
    .wrap{ gap:clamp(12px,3vh,20px); }
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#050506;
      --board:var(--bg);
      --tile:#0E1012;
      --block:#8B96A3;
      --text:#E0E3EA;
      --shadow:0 18px 40px rgba(0,0,0,.65);
    }
  }

  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font:500 18px/1.45 "Inter", system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    gap:24px;
    padding:20px clamp(12px,4vw,24px) 24px;
    min-height:100vh;
    min-height:100dvh;
    user-select:none;
    -webkit-user-select:none;
    touch-action:manipulation;
  }
  .wrap,
  .board,
  .tray,
  .piece,
  .piece-inner,
  .topbar{
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
  }

  .topbar{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:clamp(10px,3vw,14px) clamp(18px,4vw,26px);
    border-radius:999px;
    border:1px solid rgba(0,0,0,.04);
    background:rgba(255,255,255,.75);
    backdrop-filter:blur(18px);
    box-shadow:0 10px 30px rgba(0,0,0,.08);
    font-size:clamp(16px,4vw,20px);
    letter-spacing:.2px;
    color:var(--text);
  }
  @media (prefers-color-scheme: dark){
    .topbar{
      background:rgba(14,15,16,.85);
      border-color:rgba(255,255,255,.08);
      box-shadow:0 14px 40px rgba(0,0,0,.65);
    }
  }
  .btn{
    background:transparent;
    border:none;
    font-weight:600;
    font-size:clamp(16px,4vw,20px);
    color:var(--text);
    cursor:pointer;
    padding:0;
  }
  .btn:active{opacity:.7}
  .score{
    font-weight:700;
    font-size:clamp(26px,6vw,32px);
    letter-spacing:.4px;
    color:var(--text);
  }
  .icon-btn{
    position:absolute;
    right:clamp(12px,4vw,20px);
    top:50%;
    transform:translateY(-50%);
    width:clamp(38px,10vw,44px);
    height:clamp(38px,10vw,44px);
    border-radius:50%;
    border:none;
    background:rgba(255,255,255,.9);
    box-shadow:0 6px 16px rgba(0,0,0,.08);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    color:var(--text);
  }
  .icon-btn svg{
    width:clamp(18px,5vw,22px);
    height:clamp(18px,5vw,22px);
    stroke:currentColor;
  }
  .icon-btn:active{opacity:.8}

  .wrap{
    width:100%;
    max-width:var(--max-width);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:clamp(16px,4vw,28px);
  }

  .board{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    aspect-ratio:1/1;
    background:var(--board);
    display:grid;
    grid-template-columns:repeat(10,1fr);
    grid-template-rows:repeat(10,1fr);
    gap:var(--grid-gap);
    padding:clamp(8px,2.4vw,16px);
    border-radius:18px;
    box-shadow:none;
  }
  .board.dragging{
    box-shadow:none;
  }
  .cell{
    position:relative;
    overflow:hidden;
    background:var(--tile);
    border-radius:var(--cell-radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    transition:transform .15s ease, background .2s ease, box-shadow .2s ease;
  }
  .cell.filled{
    background:var(--block);
    box-shadow:none;
  }
  .cell.preview{
    box-shadow:0 0 0 3px rgba(87,96,106,.35) inset;
  }
  .cell.clearing{
    animation:clearSentinel .35s ease forwards;
    animation-delay:var(--clear-delay,0s);
  }
  .cell.clearing::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:inherit;
    background:var(--block);
    animation:cascadeClear .35s ease forwards;
    animation-delay:var(--clear-delay,0s);
  }
  @keyframes clearSentinel{
    0%{opacity:1;}
    100%{opacity:1;}
  }
  @keyframes cascadeClear{
    0%{transform:scale(1);opacity:1;}
    100%{transform:translateY(-10px);opacity:0;}
  }
  .board.shake{animation:shake .15s}
  @keyframes shake{0%{transform:translateX(0)}33%{transform:translateX(-4px)}66%{transform:translateX(4px)}100%{transform:translateX(0)}}

  .tray{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    margin:0 auto;
    display:flex;
    align-items:stretch;
    justify-content:space-between;
    gap:var(--piece-gap, clamp(8px, 2vw, 18px));
    overflow:visible;
  }
  .piece{
    flex:1 1 0;
    min-width:0;
    background:transparent;
    border:none;
    border-radius:16px;
    padding:12px 0;
    cursor:grab;
    box-shadow:none;
    transition:transform .2s ease;
    touch-action:none;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:120px;
    overflow:visible;
  }
  .piece:active{cursor:grabbing}
  .piece.selected{ transform:scale(1.03); }
  .piece.dragging{
    visibility:hidden;
  }
  .drag-ghost,
  .pointer-ghost{
    position:fixed;
    top:0;
    left:0;
    pointer-events:none;
    z-index:1000;
    transform:translate(-9999px,-9999px);
    will-change:transform;
  }
  .drag-ghost{
    z-index:-1;
  }
  .piece-inner{
    display:grid;
    gap:var(--grid-gap);
    justify-items:stretch;
    align-items:stretch;
  }
  .drag-ghost{
    position:fixed;
    top:-9999px;
    left:-9999px;
    pointer-events:none;
    z-index:0;
  }

  .b{
    width:100%;
    height:100%;
    background:var(--block);
    border-radius:var(--pip-radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.18);
  }

  /* modal */
  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; padding:24px }
  .modal.show{ display:flex }
  .sheet{ background:#fff; color:var(--text); width:100%; max-width:380px; border-radius:16px; padding:20px; text-align:center }
  .sheet h2{ margin:0 0 8px 0 } .sheet p{ margin:0 0 16px 0; opacity:.8 }
</style>
</head>
<body>
  <div class="topbar">
    <div class="score" id="score">0</div>
    <button class="icon-btn" id="resetBtn" aria-label="Reset game">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
        <path d="M3 4v6h6"></path>
        <path d="M21 20v-6h-6"></path>
        <path d="M5.64 17.66a9 9 0 0 0 12.73 0L21 15"></path>
        <path d="M3 9l2.64-2.66a9 9 0 0 1 12.73 0L21 9"></path>
      </svg>
    </button>
  </div>

  <div class="wrap">
    <div id="board" class="board" aria-label="game board" role="grid"></div>
    <div class="tray" id="tray" aria-label="piece tray"></div>
  </div>

  <div class="modal" id="gameOver">
    <div class="sheet">
      <h2>Game Over</h2>
      <p>Final score: <span id="finalScore">0</span></p>
      <button class="btn" id="againBtn">Play again</button>
    </div>
  </div>

<script>
/* ------- Minimal 1010 (drag-and-drop) ------- */
const BOARD=10, EMPTY=0, FILLED=1;
const CLEAR_DELAY_STEP_MS=50;
const TRAY_SCALE=0.74;
const MIN_TRAY_CELL=18;
const MIN_TRAY_GAP=4;
let grid, score=0, tray=[], selected=null;
let boardCellSize=0, boardGap=8, isClearing=false;
let pendingAnchor=null, pendingAnchorIdx=null;
let currentPreview=null;
let draggingPiece=false;
let resizeScheduled=false;
let currentBoardPixels=0;
let pointerDragId=null;
let pointerCaptureTarget=null;
let dragGhost=null;
let pointerGhost=null;
let pointerGhostOffset={x:0,y:0};

const ZERO_ANCHOR=()=>({dx:0,dy:0});

function getSelectedAnchor(){
  return (selected && selected.anchor) ? selected.anchor : ZERO_ANCHOR();
}

function buildPlacementOffsets(shape){
  const anchor=getSelectedAnchor();
  const offsets=[];
  const seen=new Set();
  const add=(dx,dy)=>{
    const key=`${dx},${dy}`;
    if(!seen.has(key)){ seen.add(key); offsets.push({dx,dy}); }
  };
  add(anchor.dx, anchor.dy);
  shape.forEach(([dx,dy])=>add(dx,dy));
  return offsets;
}

function findPlacementOrigin(x,y){
  if(!selected || !selected.shape || !Number.isFinite(x) || !Number.isFinite(y)) return null;
  const shape=selected.shape;
  const offsets=buildPlacementOffsets(shape);
  for(const off of offsets){
    const ox=x-off.dx, oy=y-off.dy;
    if(canPlaceAt(ox,oy,shape)) return {ox,oy};
  }
  return null;
}

function computeBoardPixels(){
  const rootStyles=getComputedStyle(document.documentElement);
  const maxWidth=parseFloat(rootStyles.getPropertyValue('--max-width')) || 520;
  const vw=Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
  const bodyStyles=getComputedStyle(document.body);
  const horizontalPadding=parseFloat(bodyStyles.paddingLeft)+parseFloat(bodyStyles.paddingRight);
  const verticalPadding=parseFloat(bodyStyles.paddingTop)+parseFloat(bodyStyles.paddingBottom);
  const topbar=document.querySelector('.topbar');
  const wrap=document.querySelector('.wrap');
  const topHeight=topbar?topbar.offsetHeight:0;
  const wrapGap=wrap?parseFloat(getComputedStyle(wrap).gap)||0:0;
  const trayHeight=trayEl?trayEl.offsetHeight:0;
  let availableWidth=Math.min(maxWidth, vw-horizontalPadding);
  availableWidth=Math.max(180, availableWidth);
  let availableHeight=window.innerHeight - (verticalPadding + topHeight + wrapGap + trayHeight + 40);
  if(!Number.isFinite(availableHeight) || availableHeight<=0) availableHeight=availableWidth;
  let size=Math.min(availableWidth, availableHeight);
  return Math.max(180, size);
}

function applyBoardSize(){
  const size=computeBoardPixels();
  if(Math.abs(size-currentBoardPixels)<=1) return;
  currentBoardPixels=size;
  document.documentElement.style.setProperty('--board-size', size+'px');
  window.requestAnimationFrame(()=>{ recomputeBoardMetrics(); });
}

function scheduleResponsiveSize(){
  if(resizeScheduled) return;
  resizeScheduled=true;
  window.requestAnimationFrame(()=>{
    resizeScheduled=false;
    applyBoardSize();
    setTimeout(applyBoardSize, 80);
  });
}

function recomputeBoardMetrics(){
  const someCell=boardEl.firstElementChild;
  if(!someCell) return;
  const newSize=Math.round(someCell.getBoundingClientRect().width);
  if(!newSize || newSize===boardCellSize) return;
  boardCellSize=newSize;
  const gapPx=Math.max(2, Math.min(8, boardCellSize*0.08));
  boardGap=gapPx;
  document.documentElement.style.setProperty('--grid-gap', gapPx+'px');
  const trayGap=Math.max(12, gapPx*3);
  trayEl.style.setProperty('--piece-gap', trayGap+'px');
  const radius=Math.max(3, Math.min(8, boardCellSize*0.06));
  document.documentElement.style.setProperty('--cell-radius', radius+'px');
  document.documentElement.style.setProperty('--pip-radius', Math.max(0, radius-2)+'px');
  renderTray();
}

const SHAPES=[
  [[0,0]],
  [[0,0],[1,0]], [[0,0],[0,1]],
  [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
  [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
  [[0,0],[1,0],[2,0],[3,0],[4,0]], [[0,0],[0,1],[0,2],[0,3],[0,4]],
  [[0,0],[1,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2]],
  [[0,0],[0,1],[0,2],[1,2]],
  [[0,0],[1,0],[2,0],[1,1]],
  [[0,0],[1,0],[1,1],[2,1]],
  [[0,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[2,1]],
];

const boardEl=document.getElementById('board');
const trayEl=document.getElementById('tray');
const scoreEl=document.getElementById('score');
const gameOverEl=document.getElementById('gameOver');
const finalScoreEl=document.getElementById('finalScore');

function buildBoard(){
  boardEl.innerHTML='';
  for(let i=0;i<BOARD*BOARD;i++){
    const d=document.createElement('div');
    d.className='cell';
    d.dataset.x=(i%BOARD);
    d.dataset.y=Math.floor(i/BOARD);
    d.addEventListener('pointerenter', previewHover);
    d.addEventListener('pointerleave', ()=>{ if(selected && !draggingPiece) clearPreviewAll(); });
    d.addEventListener('dragover', handleDragOver);
    d.addEventListener('drop', handleDrop);
    boardEl.appendChild(d);
  }
  const someCell=boardEl.firstElementChild;
  boardCellSize=Math.round(someCell.getBoundingClientRect().width);
  trayEl.style.setProperty('--piece-gap', boardCellSize<40 ? '16px' : '26px');
}

function newGrid(){ grid=Array.from({length:BOARD},()=>Array(BOARD).fill(EMPTY)); updateBoardCells(); }
function dealPiece(){ return {shape: JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random()*SHAPES.length)]))}; }
function refillTray(){
  tray=[dealPiece(),dealPiece(),dealPiece()];
  selected=null;
  clearPreviewAll();
  clearPendingAnchor();
  renderTray();
}

function drawPiece(container,shape,{fullSize=false}={}){
  container.innerHTML='';
  const xs=shape.map(s=>s[0]), ys=shape.map(s=>s[1]);
  const w=Math.max(...xs)+1, h=Math.max(...ys)+1;
  const baseCell=boardCellSize || 32;
  const baseGap=boardGap || 6;
  const miniCell=Math.max(MIN_TRAY_CELL, Math.round(baseCell*TRAY_SCALE));
  const miniGap=Math.max(MIN_TRAY_GAP, Math.round(baseGap*TRAY_SCALE));
  const cellSize=fullSize ? baseCell : miniCell;
  const gap=fullSize ? baseGap : miniGap;
  const width=(w*cellSize)+Math.max(0,w-1)*gap;
  const height=(h*cellSize)+Math.max(0,h-1)*gap;
  container.style.display='grid';
  container.style.width=width+'px';
  container.style.height=height+'px';
  container.style.gridTemplateColumns=`repeat(${w}, ${cellSize}px)`;
  container.style.gridTemplateRows=`repeat(${h}, ${cellSize}px)`;
  container.style.gap=gap+'px';
  const parentEl=container.parentElement;
  if(parentEl && parentEl!==document.body){
    parentEl.style.minHeight=(height+20)+'px';
  }
  shape.forEach(([x,y])=>{
    const b=document.createElement('div'); b.className='b';
    b.dataset.cx=x;
    b.dataset.cy=y;
    b.style.gridColumn=(x+1);
    b.style.gridRow=(y+1);
    container.appendChild(b);
  });
}

function createDragGhost(shape){
  const ghost=document.createElement('div');
  ghost.className='drag-ghost';
  ghost.style.padding='0';
  ghost.style.margin='0';
  ghost.style.background='transparent';
  document.body.appendChild(ghost);
  drawPiece(ghost,shape,{fullSize:true});
  return ghost;
}

function createPointerGhost(shape){
  removePointerGhost();
  pointerGhost=document.createElement('div');
  pointerGhost.className='pointer-ghost';
  document.body.appendChild(pointerGhost);
  drawPiece(pointerGhost,shape,{fullSize:true});
  const rect=pointerGhost.getBoundingClientRect();
  const yOffset=Math.max(20, rect.height*0.2);
  pointerGhostOffset={
    x:rect.width/2,
    y:rect.height + yOffset
  };
  return pointerGhost;
}

function updatePointerGhostPosition(e){
  if(!pointerGhost) return;
  const cx=typeof e.clientX==='number' ? e.clientX : 0;
  const cy=typeof e.clientY==='number' ? e.clientY : 0;
  pointerGhost.style.transform=`translate(${cx-pointerGhostOffset.x}px, ${cy-pointerGhostOffset.y}px)`;
}

function removePointerGhost(){
  if(pointerGhost){
    pointerGhost.remove();
    pointerGhost=null;
    pointerGhostOffset={x:0,y:0};
  }
}

function renderTray(){
  trayEl.innerHTML='';
  tray.forEach((p,idx)=>{
    const card=document.createElement('div');
    const isActive=selected && selected.idx===idx;
    const isDraggingActive=isActive && draggingPiece;
    card.className='piece'+(isActive?' selected':'')+(isDraggingActive?' dragging':'');
    card.setAttribute('draggable','true');
    card.addEventListener('pointerdown', e=>handlePiecePointerDown(e,idx));
    card.addEventListener('dragstart', e=>beginDrag(e,idx));
    card.addEventListener('dragend', finishDrag);
    trayEl.appendChild(card);
    const inner=document.createElement('div'); inner.className='piece-inner'; card.appendChild(inner);
    drawPiece(inner,p.shape);
  });
}

function handlePiecePointerDown(e,idx){
  rememberAnchor(e,idx);
  if(e.pointerType==='mouse' || e.pointerType==='pen'){
    return;
  }
  if(isClearing || draggingPiece) return;
  e.preventDefault();
  startPointerDrag(e,idx);
}

function startPointerDrag(e,idx){
  const anchor = takeAnchorFromDrag(e,idx);
  selected={shape:tray[idx].shape, idx, anchor};
  setTimeout(()=>renderTray(),0);
  draggingPiece=true;
  pointerDragId=e.pointerId;
  pointerCaptureTarget=e.currentTarget;
  if(pointerCaptureTarget && pointerCaptureTarget.setPointerCapture){
    try{ pointerCaptureTarget.setPointerCapture(e.pointerId); }catch(err){}
  }
  pointerGhost=createPointerGhost(tray[idx].shape);
  boardEl.classList.add('dragging');
  window.addEventListener('pointermove', handlePointerMove);
  window.addEventListener('pointerup', handlePointerUp);
  window.addEventListener('pointercancel', handlePointerCancel);
  updatePointerPreview(e);
  updatePointerGhostPosition(e);
}

function handlePointerMove(e){
  if(e.pointerId!==pointerDragId) return;
  e.preventDefault();
  updatePointerPreview(e);
  updatePointerGhostPosition(e);
}

function handlePointerUp(e){
  if(e.pointerId!==pointerDragId) return;
  e.preventDefault();
  finalizePointerDrag(e);
}

function handlePointerCancel(e){
  if(e.pointerId!==pointerDragId) return;
  e.preventDefault();
  cancelPointerDrag();
}

function updatePointerPreview(e){
  const cell=getCellFromPoint(e);
  if(cell){
    showPreviewAt(+cell.dataset.x, +cell.dataset.y);
  }else{
    clearPreviewAll();
  }
}

function finalizePointerDrag(e){
  cleanupPointerDragListeners();
  const pointerId=pointerDragId;
  pointerDragId=null;
  const cell=getCellFromPoint(e);
  let placed=false;
  if(cell){
    placed=attemptPlacement(+cell.dataset.x, +cell.dataset.y);
  }else if(currentPreview && currentPreview.origin){
    placed=attemptPlacement(null,null,currentPreview.origin);
  }
  if(!placed){
    finishDrag();
  }else{
    releaseDragUIState();
  }
}

function cancelPointerDrag(){
  cleanupPointerDragListeners();
  pointerDragId=null;
  finishDrag();
}

function cleanupPointerDragListeners(){
  window.removeEventListener('pointermove', handlePointerMove);
  window.removeEventListener('pointerup', handlePointerUp);
  window.removeEventListener('pointercancel', handlePointerCancel);
  releasePointerCapture();
}

function releasePointerCapture(){
  if(pointerCaptureTarget && pointerCaptureTarget.releasePointerCapture && pointerDragId!=null){
    try{ pointerCaptureTarget.releasePointerCapture(pointerDragId); }catch(err){}
  }
  pointerCaptureTarget=null;
}

function getCellFromPoint(e){
  if(typeof e.clientX!=='number' || typeof e.clientY!=='number') return null;
  const el=document.elementFromPoint(e.clientX, e.clientY);
  return el && el.closest('.cell');
}

function rememberAnchor(e,idx){
  const tile=e.target.closest('.b');
  if(tile){
    pendingAnchor={dx:+tile.dataset.cx, dy:+tile.dataset.cy};
    pendingAnchorIdx=idx;
  }else{
    clearPendingAnchor();
  }
}

function clearPendingAnchor(){
  pendingAnchor=null;
  pendingAnchorIdx=null;
}

function takeAnchorFromDrag(e,idx){
  const pending = (pendingAnchorIdx===idx && pendingAnchor) ? pendingAnchor : null;
  clearPendingAnchor();
  const fromPoint = anchorFromPointer(e);
  return pending || fromPoint || ZERO_ANCHOR();
}

function anchorFromPointer(e){
  if(typeof e.clientX!=='number' || typeof e.clientY!=='number') return null;
  const el=document.elementFromPoint(e.clientX, e.clientY);
  const tile=el && el.closest('.b');
  if(tile && tile.dataset.cx!=null){
    return {dx:+tile.dataset.cx, dy:+tile.dataset.cy};
  }
  return null;
}

function beginDrag(e,idx){
  if(isClearing){ e.preventDefault(); return; }
  const anchor = takeAnchorFromDrag(e,idx);
  selected={shape:tray[idx].shape, idx, anchor};
  dragGhost=createDragGhost(tray[idx].shape);
  setTimeout(()=>renderTray(),0);
  draggingPiece=true;
  boardEl.classList.add('dragging');
  if(e.dataTransfer){
    if(dragGhost){
      const rect=dragGhost.getBoundingClientRect();
      e.dataTransfer.setDragImage(dragGhost, rect.width/2, rect.height/2);
    }
    e.dataTransfer.effectAllowed='move';
    e.dataTransfer.setData('text/plain', String(idx));
  }
}

function finishDrag(){
  releaseDragUIState();
  clearPreviewAll();
  selected=null;
  renderTray();
}

function releaseDragUIState(){
  boardEl.classList.remove('dragging');
  draggingPiece=false;
  releasePointerCapture();
  removePointerGhost();
  if(dragGhost){
    dragGhost.remove();
    dragGhost=null;
  }
}

function updateBoardCells(){
  document.querySelectorAll('.cell').forEach(c=>{
    const x=+c.dataset.x, y=+c.dataset.y;
    c.classList.toggle('filled', grid[y][x]===FILLED);
    c.classList.remove('preview');
  });
}

function canPlaceAt(x,y,shape){
  return shape.every(([dx,dy])=>{
    const cx=x+dx, cy=y+dy;
    return cx>=0 && cy>=0 && cx<BOARD && cy<BOARD && grid[cy][cx]===EMPTY;
  });
}

function placeAt(x,y,shape){
  shape.forEach(([dx,dy])=>{ grid[y+dy][x+dx]=FILLED; });
  score += shape.length; scoreEl.textContent=score;
  updateBoardCells();
  clearLines();
}

function clearLines(){
  const rows=[], cols=[];
  for(let y=0;y<BOARD;y++) if(grid[y].every(v=>v===FILLED)) rows.push(y);
  for(let x=0;x<BOARD;x++){
    let ok=true;
    for(let y=0;y<BOARD;y++) if(grid[y][x]!==FILLED){ ok=false; break; }
    if(ok) cols.push(x);
  }
  if(!rows.length && !cols.length) return;

  isClearing=true;
  const coords=new Set();
  const rowSet=new Set(rows);
  const colSet=new Set(cols);
  const delayStepSeconds=CLEAR_DELAY_STEP_MS/1000;
  let pendingAnimations=0;
  let resolved=false;
  const finishClear=()=>{
    if(resolved) return;
    resolved=true;
    isClearing=false;
  };
  rows.forEach(y=>{ for(let x=0;x<BOARD;x++) coords.add(`${x},${y}`); });
  cols.forEach(x=>{ for(let y=0;y<BOARD;y++) coords.add(`${x},${y}`); });

  coords.forEach(key=>{
    const [cx,cy]=key.split(',').map(Number);
    grid[cy][cx]=EMPTY;
    const cell=document.querySelector(`.cell[data-x="${cx}"][data-y="${cy}"]`);
    if(cell){
      cell.classList.remove('filled');
      cell.classList.remove('preview');
      const rowDelay = rowSet.has(cy) ? cx*delayStepSeconds : 0;
      const colDelay = colSet.has(cx) ? cy*delayStepSeconds : 0;
      const delay = Math.max(rowDelay, colDelay);
      cell.style.setProperty('--clear-delay', `${delay}s`);
      cell.classList.add('clearing');
      pendingAnimations++;
      const handle=()=>{
        cell.classList.remove('clearing');
        cell.style.removeProperty('--clear-delay');
        if(--pendingAnimations===0) finishClear();
      };
      cell.addEventListener('animationend', handle, {once:true});
    }
  });

  score += (rows.length+cols.length)*10;
  scoreEl.textContent=score;
  if(pendingAnimations===0) finishClear();
}

function previewHover(e){
  showPreviewAt(+e.currentTarget.dataset.x, +e.currentTarget.dataset.y);
}

function showPreviewAt(x,y){
  if(!selected) return;
  const origin=findPlacementOrigin(x,y);
  clearPreviewAll();
  if(!origin) return;
  const {ox,oy}=origin;
  const shape=selected.shape;
  const cells=[];
  shape.forEach(([dx,dy])=>{
    const cell=document.querySelector(`.cell[data-x="${ox+dx}"][data-y="${oy+dy}"]`);
    if(cell){
      cell.classList.add('preview');
      cells.push(cell);
    }
  });
  currentPreview={origin, cells};
}

function clearPreviewAll(){
  if(currentPreview && currentPreview.cells){
    currentPreview.cells.forEach(cell=>cell.classList.remove('preview'));
  }else{
    document.querySelectorAll('.cell.preview').forEach(c=>c.classList.remove('preview'));
  }
  currentPreview=null;
}

function handleDragOver(e){
  if(!selected) return;
  e.preventDefault();
  if(e.dataTransfer) e.dataTransfer.dropEffect='move';
  const cell=e.currentTarget;
  showPreviewAt(+cell.dataset.x, +cell.dataset.y);
}

function handleDrop(e){
  if(!selected) return;
  e.preventDefault();
  e.stopPropagation();
  const cell=e.currentTarget;
  attemptPlacement(+cell.dataset.x, +cell.dataset.y);
}

boardEl.addEventListener('dragover', handleBoardDragOver);
boardEl.addEventListener('drop', handleBoardDrop);
boardEl.addEventListener('pointerleave', ()=>{ if(!draggingPiece) clearPreviewAll(); });

function handleBoardDragOver(e){
  if(!selected) return;
  e.preventDefault();
  if(e.dataTransfer) e.dataTransfer.dropEffect='move';
  const cell=e.target.closest('.cell');
  if(cell) showPreviewAt(+cell.dataset.x, +cell.dataset.y);
}

function handleBoardDrop(e){
  if(!selected) return;
  e.preventDefault();
  if(currentPreview && currentPreview.origin){
    attemptPlacement(null,null,currentPreview.origin);
  }else{
    const cell=e.target.closest('.cell');
    if(cell) attemptPlacement(+cell.dataset.x, +cell.dataset.y);
  }
}

function attemptPlacement(x,y,originOverride=null){
  if(!selected) return false;
  if(isClearing){ bumpBoard(); return false; }
  const piece=selected.shape;
  const idx=selected.idx;
  let origin=originOverride;
  if(!origin && Number.isFinite(x) && Number.isFinite(y)){
    origin=findPlacementOrigin(x,y);
  }
  if(!origin && currentPreview) origin=currentPreview.origin;
  if(!origin){
    bumpBoard();
    return false;
  }
  const {ox,oy}=origin;
  placeAt(ox,oy,piece);
  if(typeof idx==='number') tray.splice(idx,1);
  selected=null;
  clearPreviewAll();
  if(tray.length===0){ refillTray(); } else { renderTray(); }
  checkGameOver();
  return true;
}

function bumpBoard(){
  boardEl.classList.remove('shake'); void boardEl.offsetWidth; boardEl.classList.add('shake');
}

function checkGameOver(){
  const anyFit = tray.length && tray.some(p=>{
    for(let y=0;y<BOARD;y++) for(let x=0;x<BOARD;x++) if(canPlaceAt(x,y,p.shape)) return true;
    return false;
  });
  if(tray.length && !anyFit){ finalScoreEl.textContent=score; gameOverEl.classList.add('show'); }
}

/* controls */
document.getElementById('resetBtn').onclick=()=>start();
document.getElementById('againBtn').onclick=()=>{ gameOverEl.classList.remove('show'); start(); };

/* boot */
function start(){
  score=0;
  scoreEl.textContent=score;
  selected=null;
  isClearing=false;
  clearPreviewAll();
  boardEl.classList.remove('dragging');
  buildBoard(); newGrid(); clearPendingAnchor(); refillTray();
  scheduleResponsiveSize();
}
start();

window.addEventListener('resize', scheduleResponsiveSize);
window.addEventListener('orientationchange', scheduleResponsiveSize);

if('serviceWorker' in navigator){
  window.addEventListener('load', ()=>{
    navigator.serviceWorker.register('./sw.js').catch(err=>{
      console.warn('Service worker registration failed', err);
    });
  });
}
</script>
</body>
</html>
