<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>1010 — Minimal</title>
<style>
  :root{
    --bg:#F8F7F5;          /* page & board background */
    --tile:#FFFFFF;        /* tile fill (white) */
    --outline:var(--bg);   /* outlines use the background color */
    --text:#111213;
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0E0F10;
      --tile:#FFFFFF;
      --outline:#0E0F10;
      --text:#EDEEF0;
    }
  }

  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:16px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px;
  }

  /* top bar */
  .topbar{width:100%; max-width:520px; display:flex; align-items:center; justify-content:space-between; padding:8px 6px;}
  .btn{background:transparent; border:none; font-weight:700; font-size:18px; letter-spacing:.2px; cursor:pointer}
  .btn:active{opacity:.7}
  .score{font-weight:700; font-size:18px}

  .wrap{width:100%; max-width:520px; display:flex; flex-direction:column; align-items:center; gap:16px}

  /* board: same bg as page; outlines = bg; tiles = white; rounded corners per cell */
  .board{
    width:100%; aspect-ratio:1/1; background:var(--bg);
    display:grid; grid-template-columns:repeat(10,1fr); grid-template-rows:repeat(10,1fr);
  }
  .cell{
    background:transparent;
    border:1px solid var(--outline);     /* white-on-bg look comes from these lines */
    border-radius:10px;                  /* more rounded corners */
  }
  .cell.filled{
    background:var(--tile);              /* white tiles */
    border-color:var(--outline);         /* keep per-cell lines visible between adjacent tiles */
  }
  .cell.preview{ outline:2px solid rgba(255,255,255,.6); outline-offset:-2px; border-radius:10px }
  .board.shake{animation:shake .15s}
  @keyframes shake{0%{transform:translateX(0)}33%{transform:translateX(-4px)}66%{transform:translateX(4px)}100%{transform:translateX(0)}}

  /* tray: pieces drawn at exact board 1×1 size, centered; each mini tile has same styling */
  .tray{ width:100%; display:flex; align-items:center; justify-content:center; gap:16px; }
  .piece{ background:transparent; padding:6px; border-radius:12px; cursor:pointer; display:grid; place-items:center; }
  .piece.selected{ outline:2px solid #fff; outline-offset:2px; border-radius:12px; }
  .piece-inner{ position:relative; }

  .b{
    position:absolute; width:100%; height:100%;
    background:var(--tile);
    border:1px solid var(--outline);    /* same per-tile outline as board */
    border-radius:10px;
  }

  /* modal */
  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; padding:24px }
  .modal.show{ display:flex }
  .sheet{ background:#fff; color:var(--text); width:100%; max-width:380px; border-radius:16px; padding:20px; text-align:center }
  .sheet h2{ margin:0 0 8px 0 } .sheet p{ margin:0 0 16px 0; opacity:.8 }
</style>
</head>
<body>
  <div class="topbar">
    <button class="btn" id="resetBtn">Reset</button>
    <div class="score" id="score">0</div>
    <button class="btn" id="moreBtn">⋯</button>
  </div>

  <div class="wrap">
    <div id="board" class="board" aria-label="game board" role="grid"></div>
    <div class="tray" id="tray" aria-label="piece tray"></div>
  </div>

  <div class="modal" id="gameOver">
    <div class="sheet">
      <h2>Game Over</h2>
      <p>Final score: <span id="finalScore">0</span></p>
      <button class="btn" id="againBtn">Play again</button>
    </div>
  </div>

<script>
/* ------- Minimal 1010 (tap-to-place) ------- */
const BOARD=10, EMPTY=0, FILLED=1;
let grid, score=0, tray=[], selected=null;
let boardCellSize=0;

const SHAPES=[
  [[0,0]], [[0,0],[1,0]], [[0,0],[1,0],[2,0]], [[0,0],[1,0],[2,0],[3,0]], [[0,0],[1,0],[2,0],[3,0],[4,0]],
  [[0,0],[1,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2]],
  [[0,0],[0,1],[0,2],[1,2]],
  [[0,0],[1,0],[2,0],[1,1]],
  [[0,0],[1,0],[1,1],[2,1]],
  [[0,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[2,1]],
];

const boardEl=document.getElementById('board');
const trayEl=document.getElementById('tray');
const scoreEl=document.getElementById('score');
const gameOverEl=document.getElementById('gameOver');
const finalScoreEl=document.getElementById('finalScore');

function buildBoard(){
  boardEl.innerHTML='';
  for(let i=0;i<BOARD*BOARD;i++){
    const d=document.createElement('div');
    d.className='cell';
    d.dataset.x=(i%BOARD);
    d.dataset.y=Math.floor(i/BOARD);
    d.addEventListener('pointerenter', previewHover);
    d.addEventListener('pointerleave', ()=>d.classList.remove('preview'));
    d.addEventListener('click', tryPlaceHere);
    boardEl.appendChild(d);
  }
  const someCell=boardEl.firstElementChild;
  boardCellSize=Math.round(someCell.getBoundingClientRect().width);
}

function newGrid(){ grid=Array.from({length:BOARD},()=>Array(BOARD).fill(EMPTY)); updateBoardCells(); }
function dealPiece(){ return {shape: JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random()*SHAPES.length)]))}; }
function refillTray(){ tray=[dealPiece(),dealPiece(),dealPiece()]; renderTray(); }

function drawPiece(container,shape){
  container.innerHTML='';
  const xs=shape.map(s=>s[0]), ys=shape.map(s=>s[1]);
  const w=Math.max(...xs)+1, h=Math.max(...ys)+1;
  container.style.width = (w*boardCellSize)+'px';
  container.style.height= (h*boardCellSize)+'px';
  container.parentElement.style.width  = (w*boardCellSize+12)+'px';
  container.parentElement.style.height = (h*boardCellSize+12)+'px';
  shape.forEach(([x,y])=>{
    const b=document.createElement('div'); b.className='b';
    b.style.left=(x*boardCellSize)+'px'; b.style.top=(y*boardCellSize)+'px';
    b.style.width=boardCellSize+'px'; b.style.height=boardCellSize+'px';
    container.appendChild(b);
  });
}

function renderTray(){
  trayEl.innerHTML='';
  tray.forEach((p,idx)=>{
    const card=document.createElement('div'); card.className='piece'+(selected&&selected.idx===idx?' selected':'');
    card.onclick=()=>{ selected=(selected&&selected.idx===idx)?null:{shape:p.shape,idx}; renderTray(); clearPreviewAll(); };
    const inner=document.createElement('div'); inner.className='piece-inner'; card.appendChild(inner); trayEl.appendChild(card);
    drawPiece(inner,p.shape);
  });
}

function updateBoardCells(){
  document.querySelectorAll('.cell').forEach(c=>{
    const x=+c.dataset.x, y=+c.dataset.y;
    c.classList.toggle('filled', grid[y][x]===FILLED);
    c.classList.remove('preview');
  });
}

function canPlaceAt(x,y,shape){
  return shape.every(([dx,dy])=>{
    const cx=x+dx, cy=y+dy;
    return cx>=0 && cy>=0 && cx<BOARD && cy<BOARD && grid[cy][cx]===EMPTY;
  });
}

function placeAt(x,y,shape){
  shape.forEach(([dx,dy])=>{ grid[y+dy][x+dx]=FILLED; });
  score += shape.length; scoreEl.textContent=score;
  clearLines(); updateBoardCells();
}

function clearLines(){
  const rows=[], cols=[];
  for(let y=0;y<BOARD;y++) if(grid[y].every(v=>v===FILLED)) rows.push(y);
  for(let x=0;x<BOARD;x++){ let ok=true; for(let y=0;y<BOARD;y++) if(grid[y][x]!==FILLED){ok=false;break;} if(ok) cols.push(x); }
  if(rows.length||cols.length){
    rows.forEach(y=> grid[y]=Array(BOARD).fill(EMPTY));
    cols.forEach(x=>{ for(let y=0;y<BOARD;y++) grid[y][x]=EMPTY; });
    score += (rows.length+cols.length)*10; scoreEl.textContent=score;
  }
}

function previewHover(e){
  if(!selected) return; clearPreviewAll();
  const x=+e.currentTarget.dataset.x, y=+e.currentTarget.dataset.y, shape=selected.shape;
  if(canPlaceAt(x,y,shape)) shape.forEach(([dx,dy])=>{
    const cell=document.querySelector(`.cell[data-x="${x+dx}"][data-y="${y+dy}"]`); if(cell) cell.classList.add('preview');
  });
}
function clearPreviewAll(){ document.querySelectorAll('.cell.preview').forEach(c=>c.classList.remove('preview')); }

function tryPlaceHere(e){
  if(!selected) return;
  const x=+e.currentTarget.dataset.x, y=+e.currentTarget.dataset.y;
  const piece=selected.shape, idx=selected.idx;
  if(canPlaceAt(x,y,piece)){
    placeAt(x,y,piece);
    tray.splice(idx,1); selected=null;
    if(tray.length===0) refillTray(); else renderTray();
    clearPreviewAll(); checkGameOver();
  }else{
    boardEl.classList.remove('shake'); void boardEl.offsetWidth; boardEl.classList.add('shake');
  }
}

function checkGameOver(){
  const anyFit = tray.length && tray.some(p=>{
    for(let y=0;y<BOARD;y++) for(let x=0;x<BOARD;x++) if(canPlaceAt(x,y,p.shape)) return true;
    return false;
  });
  if(tray.length && !anyFit){ finalScoreEl.textContent=score; gameOverEl.classList.add('show'); }
}

/* controls */
document.getElementById('resetBtn').onclick=()=>start();
document.getElementById('againBtn').onclick=()=>{ gameOverEl.classList.remove('show'); start(); };

/* boot */
function start(){ score=0; scoreEl.textContent=score; buildBoard(); newGrid(); refillTray(); }
start();
</script>
</body>
</html>
