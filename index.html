<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>1010 â€” Minimal</title>
<style>
  :root{
    --bg:#F4F1EB;
    --board:var(--bg);
    --tile:#FFFFFF;
    --block:#57606A;
    --text:#8A8172;
    --shadow:0 14px 45px rgba(39,36,29,.12);
    --max-width:520px;
    --board-size:520px;
    --cell-radius:10px;
    --pip-radius:8px;
    --grid-gap:8px;
  }
  @media (max-height: 760px){
    body{ gap:clamp(12px,3vh,18px); padding-top:16px; padding-bottom:16px; }
    .wrap{ gap:clamp(12px,3vh,20px); }
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#050506;
      --board:var(--bg);
      --tile:#0E1012;
      --block:#8B96A3;
      --text:#E0E3EA;
      --shadow:0 18px 40px rgba(0,0,0,.65);
    }
  }

  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font:500 18px/1.45 "Inter", system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    gap:24px;
    padding:20px clamp(12px,4vw,24px) 24px;
    min-height:100vh;
    min-height:100dvh;
  }

  .topbar{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:clamp(10px,3vw,14px) clamp(18px,4vw,26px);
    border-radius:999px;
    border:1px solid rgba(0,0,0,.04);
    background:rgba(255,255,255,.75);
    backdrop-filter:blur(18px);
    box-shadow:0 10px 30px rgba(0,0,0,.08);
    font-size:clamp(16px,4vw,20px);
    letter-spacing:.2px;
    color:var(--text);
  }
  @media (prefers-color-scheme: dark){
    .topbar{
      background:rgba(14,15,16,.85);
      border-color:rgba(255,255,255,.08);
      box-shadow:0 14px 40px rgba(0,0,0,.65);
    }
  }
  .btn{
    background:transparent;
    border:none;
    font-weight:600;
    font-size:clamp(16px,4vw,20px);
    color:var(--text);
    cursor:pointer;
    padding:0;
  }
  .btn:active{opacity:.7}
  .score{
    font-weight:700;
    font-size:clamp(26px,6vw,32px);
    letter-spacing:.4px;
    color:var(--text);
  }
  .icon-btn{
    position:absolute;
    right:clamp(12px,4vw,20px);
    top:50%;
    transform:translateY(-50%);
    width:clamp(38px,10vw,44px);
    height:clamp(38px,10vw,44px);
    border-radius:50%;
    border:none;
    background:rgba(255,255,255,.9);
    box-shadow:0 6px 16px rgba(0,0,0,.08);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    color:var(--text);
  }
  .icon-btn svg{
    width:clamp(18px,5vw,22px);
    height:clamp(18px,5vw,22px);
    stroke:currentColor;
  }
  .icon-btn:active{opacity:.8}

  .wrap{
    width:100%;
    max-width:var(--max-width);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:clamp(16px,4vw,28px);
  }

  .board{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    aspect-ratio:1/1;
    background:var(--board);
    display:grid;
    grid-template-columns:repeat(10,1fr);
    grid-template-rows:repeat(10,1fr);
    gap:var(--grid-gap);
    padding:clamp(8px,2.4vw,16px);
    border-radius:18px;
    box-shadow:none;
  }
  .board.dragging{
    box-shadow:none;
  }
  .cell{
    position:relative;
    overflow:hidden;
    background:var(--tile);
    border-radius:var(--cell-radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    transition:transform .15s ease, background .2s ease, box-shadow .2s ease;
  }
  .cell.filled{
    background:var(--block);
    box-shadow:none;
  }
  .cell.preview{
    box-shadow:0 0 0 3px rgba(87,96,106,.35) inset;
  }
  .cell.clearing{
    animation:clearSentinel .35s ease forwards;
    animation-delay:var(--clear-delay,0s);
  }
  .cell.clearing::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:inherit;
    background:var(--block);
    animation:cascadeClear .35s ease forwards;
    animation-delay:var(--clear-delay,0s);
  }
  @keyframes clearSentinel{
    0%{opacity:1;}
    100%{opacity:1;}
  }
  @keyframes cascadeClear{
    0%{transform:scale(1);opacity:1;}
    100%{transform:translateY(-10px);opacity:0;}
  }
  .board.shake{animation:shake .15s}
  @keyframes shake{0%{transform:translateX(0)}33%{transform:translateX(-4px)}66%{transform:translateX(4px)}100%{transform:translateX(0)}}

  .tray{
    width:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:var(--piece-gap,26px);
    flex-wrap:nowrap;
    overflow:visible;
  }
  .piece{
    flex:0 0 auto;
    background:transparent;
    border:none;
    border-radius:14px;
    padding:8px 0;
    cursor:grab;
    box-shadow:none;
    transition:transform .2s ease;
    touch-action:none;
  }
  .piece:active{cursor:grabbing}
  .piece.selected{ transform:scale(1.03); }
  .piece-inner{
    display:grid;
    gap:var(--grid-gap);
    justify-items:stretch;
    align-items:stretch;
  }

  .b{
    width:100%;
    height:100%;
    background:var(--block);
    border-radius:var(--pip-radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.18);
  }

  /* modal */
  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; padding:24px }
  .modal.show{ display:flex }
  .sheet{ background:#fff; color:var(--text); width:100%; max-width:380px; border-radius:16px; padding:20px; text-align:center }
  .sheet h2{ margin:0 0 8px 0 } .sheet p{ margin:0 0 16px 0; opacity:.8 }
</style>
</head>
<body>
  <div class="topbar">
    <div class="score" id="score">0</div>
    <button class="icon-btn" id="resetBtn" aria-label="Reset game">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
        <path d="M3 4v6h6"></path>
        <path d="M21 20v-6h-6"></path>
        <path d="M5.64 17.66a9 9 0 0 0 12.73 0L21 15"></path>
        <path d="M3 9l2.64-2.66a9 9 0 0 1 12.73 0L21 9"></path>
      </svg>
    </button>
  </div>

  <div class="wrap">
    <div id="board" class="board" aria-label="game board" role="grid"></div>
    <div class="tray" id="tray" aria-label="piece tray"></div>
  </div>

  <div class="modal" id="gameOver">
    <div class="sheet">
      <h2>Game Over</h2>
      <p>Final score: <span id="finalScore">0</span></p>
      <button class="btn" id="againBtn">Play again</button>
    </div>
  </div>

<script>
/* ------- Minimal 1010 (drag-and-drop) ------- */
const BOARD=10, EMPTY=0, FILLED=1, PIECE_GAP=8;
const CLEAR_DELAY_STEP_MS=50;
let grid, score=0, tray=[], selected=null;
let boardCellSize=0, boardGap=8, isClearing=false;
let pendingAnchor=null, pendingAnchorIdx=null;
let currentPreview=null;
let draggingPiece=false;
let resizeScheduled=false;
let currentBoardPixels=0;

const ZERO_ANCHOR=()=>({dx:0,dy:0});

function getSelectedAnchor(){
  return (selected && selected.anchor) ? selected.anchor : ZERO_ANCHOR();
}

function buildPlacementOffsets(shape){
  const anchor=getSelectedAnchor();
  const offsets=[];
  const seen=new Set();
  const add=(dx,dy)=>{
    const key=`${dx},${dy}`;
    if(!seen.has(key)){ seen.add(key); offsets.push({dx,dy}); }
  };
  add(anchor.dx, anchor.dy);
  shape.forEach(([dx,dy])=>add(dx,dy));
  return offsets;
}

function findPlacementOrigin(x,y){
  if(!selected || !selected.shape || !Number.isFinite(x) || !Number.isFinite(y)) return null;
  const shape=selected.shape;
  const offsets=buildPlacementOffsets(shape);
  for(const off of offsets){
    const ox=x-off.dx, oy=y-off.dy;
    if(canPlaceAt(ox,oy,shape)) return {ox,oy};
  }
  return null;
}

function computeBoardPixels(){
  const rootStyles=getComputedStyle(document.documentElement);
  const maxWidth=parseFloat(rootStyles.getPropertyValue('--max-width')) || 520;
  const vw=Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
  const bodyStyles=getComputedStyle(document.body);
  const horizontalPadding=parseFloat(bodyStyles.paddingLeft)+parseFloat(bodyStyles.paddingRight);
  const verticalPadding=parseFloat(bodyStyles.paddingTop)+parseFloat(bodyStyles.paddingBottom);
  const topbar=document.querySelector('.topbar');
  const wrap=document.querySelector('.wrap');
  const topHeight=topbar?topbar.offsetHeight:0;
  const wrapGap=wrap?parseFloat(getComputedStyle(wrap).gap)||0:0;
  const trayHeight=trayEl?trayEl.offsetHeight:0;
  let availableWidth=Math.min(maxWidth, vw-horizontalPadding);
  availableWidth=Math.max(180, availableWidth);
  let availableHeight=window.innerHeight - (verticalPadding + topHeight + wrapGap + trayHeight + 40);
  if(!Number.isFinite(availableHeight) || availableHeight<=0) availableHeight=availableWidth;
  let size=Math.min(availableWidth, availableHeight);
  return Math.max(180, size);
}

function applyBoardSize(){
  const size=computeBoardPixels();
  if(Math.abs(size-currentBoardPixels)<=1) return;
  currentBoardPixels=size;
  document.documentElement.style.setProperty('--board-size', size+'px');
  window.requestAnimationFrame(()=>{ recomputeBoardMetrics(); });
}

function scheduleResponsiveSize(){
  if(resizeScheduled) return;
  resizeScheduled=true;
  window.requestAnimationFrame(()=>{
    resizeScheduled=false;
    applyBoardSize();
    setTimeout(applyBoardSize, 80);
  });
}

function recomputeBoardMetrics(){
  const someCell=boardEl.firstElementChild;
  if(!someCell) return;
  const newSize=Math.round(someCell.getBoundingClientRect().width);
  if(!newSize || newSize===boardCellSize) return;
  boardCellSize=newSize;
  const gapPx=Math.max(2, Math.min(8, boardCellSize*0.08));
  boardGap=gapPx;
  document.documentElement.style.setProperty('--grid-gap', gapPx+'px');
  const trayGap=Math.max(12, gapPx*3);
  trayEl.style.setProperty('--piece-gap', trayGap+'px');
  const radius=Math.max(4, Math.min(12, boardCellSize*0.12));
  document.documentElement.style.setProperty('--cell-radius', (radius+2)+'px');
  document.documentElement.style.setProperty('--pip-radius', Math.max(0, radius-1)+'px');
  renderTray();
}

const SHAPES=[
  [[0,0]],
  [[0,0],[1,0]], [[0,0],[0,1]],
  [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
  [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
  [[0,0],[1,0],[2,0],[3,0],[4,0]], [[0,0],[0,1],[0,2],[0,3],[0,4]],
  [[0,0],[1,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2]],
  [[0,0],[0,1],[0,2],[1,2]],
  [[0,0],[1,0],[2,0],[1,1]],
  [[0,0],[1,0],[1,1],[2,1]],
  [[0,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[2,1]],
];

const boardEl=document.getElementById('board');
const trayEl=document.getElementById('tray');
const scoreEl=document.getElementById('score');
const gameOverEl=document.getElementById('gameOver');
const finalScoreEl=document.getElementById('finalScore');

function buildBoard(){
  boardEl.innerHTML='';
  for(let i=0;i<BOARD*BOARD;i++){
    const d=document.createElement('div');
    d.className='cell';
    d.dataset.x=(i%BOARD);
    d.dataset.y=Math.floor(i/BOARD);
    d.addEventListener('pointerenter', previewHover);
    d.addEventListener('pointerleave', ()=>{ if(selected && !draggingPiece) clearPreviewAll(); });
    d.addEventListener('click', tryPlaceHere);
    d.addEventListener('dragover', handleDragOver);
    d.addEventListener('drop', handleDrop);
    boardEl.appendChild(d);
  }
  const someCell=boardEl.firstElementChild;
  boardCellSize=Math.round(someCell.getBoundingClientRect().width);
  trayEl.style.setProperty('--piece-gap', boardCellSize<40 ? '16px' : '26px');
}

function newGrid(){ grid=Array.from({length:BOARD},()=>Array(BOARD).fill(EMPTY)); updateBoardCells(); }
function dealPiece(){ return {shape: JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random()*SHAPES.length)]))}; }
function refillTray(){
  tray=[dealPiece(),dealPiece(),dealPiece()];
  selected=null;
  clearPreviewAll();
  clearPendingAnchor();
  renderTray();
}

function drawPiece(container,shape){
  container.innerHTML='';
  const xs=shape.map(s=>s[0]), ys=shape.map(s=>s[1]);
  const w=Math.max(...xs)+1, h=Math.max(...ys)+1;
  const gap=boardGap;
  const width=(w*boardCellSize)+Math.max(0,w-1)*gap;
  const height=(h*boardCellSize)+Math.max(0,h-1)*gap;
  container.style.display='grid';
  container.style.width=width+'px';
  container.style.height=height+'px';
  container.style.gridTemplateColumns=`repeat(${w}, ${boardCellSize}px)`;
  container.style.gridTemplateRows=`repeat(${h}, ${boardCellSize}px)`;
  container.style.gap=gap+'px';
  container.parentElement.style.width=(width+12)+'px';
  container.parentElement.style.height=(height+12)+'px';
  shape.forEach(([x,y])=>{
    const b=document.createElement('div'); b.className='b';
    b.dataset.cx=x;
    b.dataset.cy=y;
    b.style.gridColumn=(x+1);
    b.style.gridRow=(y+1);
    container.appendChild(b);
  });
}

function renderTray(){
  trayEl.innerHTML='';
  tray.forEach((p,idx)=>{
    const card=document.createElement('div');
    const isActive=selected && selected.idx===idx;
    card.className='piece'+(isActive?' selected':'');
    card.setAttribute('draggable','true');
    card.addEventListener('pointerdown', e=>rememberAnchor(e,idx));
    card.addEventListener('click', ()=>handlePieceClick(idx));
    card.addEventListener('dragstart', e=>beginDrag(e,idx));
    card.addEventListener('dragend', finishDrag);
    const inner=document.createElement('div'); inner.className='piece-inner'; card.appendChild(inner);
    trayEl.appendChild(card);
    drawPiece(inner,p.shape);
  });
}

function rememberAnchor(e,idx){
  const tile=e.target.closest('.b');
  if(tile){
    pendingAnchor={dx:+tile.dataset.cx, dy:+tile.dataset.cy};
    pendingAnchorIdx=idx;
  }else{
    clearPendingAnchor();
  }
}

function clearPendingAnchor(){
  pendingAnchor=null;
  pendingAnchorIdx=null;
}

function takeAnchorFromDrag(e,idx){
  const pending = (pendingAnchorIdx===idx && pendingAnchor) ? pendingAnchor : null;
  clearPendingAnchor();
  const fromPoint = anchorFromPointer(e);
  return pending || fromPoint || ZERO_ANCHOR();
}

function anchorFromPointer(e){
  if(typeof e.clientX!=='number' || typeof e.clientY!=='number') return null;
  const el=document.elementFromPoint(e.clientX, e.clientY);
  const tile=el && el.closest('.b');
  if(tile && tile.dataset.cx!=null){
    return {dx:+tile.dataset.cx, dy:+tile.dataset.cy};
  }
  return null;
}

function handlePieceClick(idx){
  clearPendingAnchor();
  if(selected && selected.idx===idx){
    selected=null;
  }else{
    selected={shape:tray[idx].shape, idx, anchor:ZERO_ANCHOR()};
  }
  clearPreviewAll();
  renderTray();
}

function beginDrag(e,idx){
  if(isClearing){ e.preventDefault(); return; }
  const anchor = takeAnchorFromDrag(e,idx);
  selected={shape:tray[idx].shape, idx, anchor};
  draggingPiece=true;
  boardEl.classList.add('dragging');
  if(e.dataTransfer){
    e.dataTransfer.effectAllowed='move';
    e.dataTransfer.setData('text/plain', String(idx));
  }
}

function finishDrag(){
  boardEl.classList.remove('dragging');
  draggingPiece=false;
  clearPreviewAll();
  if(selected) selected.anchor=ZERO_ANCHOR();
  renderTray();
}

function updateBoardCells(){
  document.querySelectorAll('.cell').forEach(c=>{
    const x=+c.dataset.x, y=+c.dataset.y;
    c.classList.toggle('filled', grid[y][x]===FILLED);
    c.classList.remove('preview');
  });
}

function canPlaceAt(x,y,shape){
  return shape.every(([dx,dy])=>{
    const cx=x+dx, cy=y+dy;
    return cx>=0 && cy>=0 && cx<BOARD && cy<BOARD && grid[cy][cx]===EMPTY;
  });
}

function placeAt(x,y,shape){
  shape.forEach(([dx,dy])=>{ grid[y+dy][x+dx]=FILLED; });
  score += shape.length; scoreEl.textContent=score;
  updateBoardCells();
  clearLines();
}

function clearLines(){
  const rows=[], cols=[];
  for(let y=0;y<BOARD;y++) if(grid[y].every(v=>v===FILLED)) rows.push(y);
  for(let x=0;x<BOARD;x++){
    let ok=true;
    for(let y=0;y<BOARD;y++) if(grid[y][x]!==FILLED){ ok=false; break; }
    if(ok) cols.push(x);
  }
  if(!rows.length && !cols.length) return;

  isClearing=true;
  const coords=new Set();
  const rowSet=new Set(rows);
  const colSet=new Set(cols);
  const delayStepSeconds=CLEAR_DELAY_STEP_MS/1000;
  let pendingAnimations=0;
  let resolved=false;
  const finishClear=()=>{
    if(resolved) return;
    resolved=true;
    isClearing=false;
  };
  rows.forEach(y=>{ for(let x=0;x<BOARD;x++) coords.add(`${x},${y}`); });
  cols.forEach(x=>{ for(let y=0;y<BOARD;y++) coords.add(`${x},${y}`); });

  coords.forEach(key=>{
    const [cx,cy]=key.split(',').map(Number);
    grid[cy][cx]=EMPTY;
    const cell=document.querySelector(`.cell[data-x="${cx}"][data-y="${cy}"]`);
    if(cell){
      cell.classList.remove('filled');
      cell.classList.remove('preview');
      const rowDelay = rowSet.has(cy) ? cx*delayStepSeconds : 0;
      const colDelay = colSet.has(cx) ? cy*delayStepSeconds : 0;
      const delay = Math.max(rowDelay, colDelay);
      cell.style.setProperty('--clear-delay', `${delay}s`);
      cell.classList.add('clearing');
      pendingAnimations++;
      const handle=()=>{
        cell.classList.remove('clearing');
        cell.style.removeProperty('--clear-delay');
        if(--pendingAnimations===0) finishClear();
      };
      cell.addEventListener('animationend', handle, {once:true});
    }
  });

  score += (rows.length+cols.length)*10;
  scoreEl.textContent=score;
  if(pendingAnimations===0) finishClear();
}

function previewHover(e){
  showPreviewAt(+e.currentTarget.dataset.x, +e.currentTarget.dataset.y);
}

function showPreviewAt(x,y){
  if(!selected) return;
  const origin=findPlacementOrigin(x,y);
  clearPreviewAll();
  if(!origin) return;
  const {ox,oy}=origin;
  const shape=selected.shape;
  const cells=[];
  shape.forEach(([dx,dy])=>{
    const cell=document.querySelector(`.cell[data-x="${ox+dx}"][data-y="${oy+dy}"]`);
    if(cell){
      cell.classList.add('preview');
      cells.push(cell);
    }
  });
  currentPreview={origin, cells};
}

function clearPreviewAll(){
  if(currentPreview && currentPreview.cells){
    currentPreview.cells.forEach(cell=>cell.classList.remove('preview'));
  }else{
    document.querySelectorAll('.cell.preview').forEach(c=>c.classList.remove('preview'));
  }
  currentPreview=null;
}

function handleDragOver(e){
  if(!selected) return;
  e.preventDefault();
  if(e.dataTransfer) e.dataTransfer.dropEffect='move';
  const cell=e.currentTarget;
  showPreviewAt(+cell.dataset.x, +cell.dataset.y);
}

function handleDrop(e){
  if(!selected) return;
  e.preventDefault();
  e.stopPropagation();
  const cell=e.currentTarget;
  attemptPlacement(+cell.dataset.x, +cell.dataset.y);
}

boardEl.addEventListener('dragover', handleBoardDragOver);
boardEl.addEventListener('drop', handleBoardDrop);
boardEl.addEventListener('pointerleave', ()=>{ if(!draggingPiece) clearPreviewAll(); });

function handleBoardDragOver(e){
  if(!selected) return;
  e.preventDefault();
  if(e.dataTransfer) e.dataTransfer.dropEffect='move';
  const cell=e.target.closest('.cell');
  if(cell) showPreviewAt(+cell.dataset.x, +cell.dataset.y);
}

function handleBoardDrop(e){
  if(!selected) return;
  e.preventDefault();
  if(currentPreview && currentPreview.origin){
    attemptPlacement(null,null,currentPreview.origin);
  }else{
    const cell=e.target.closest('.cell');
    if(cell) attemptPlacement(+cell.dataset.x, +cell.dataset.y);
  }
}

function tryPlaceHere(e){
  attemptPlacement(+e.currentTarget.dataset.x, +e.currentTarget.dataset.y);
}

function attemptPlacement(x,y,originOverride=null){
  if(!selected) return false;
  if(isClearing){ bumpBoard(); return false; }
  const piece=selected.shape;
  const idx=selected.idx;
  let origin=originOverride;
  if(!origin && Number.isFinite(x) && Number.isFinite(y)){
    origin=findPlacementOrigin(x,y);
  }
  if(!origin && currentPreview) origin=currentPreview.origin;
  if(!origin){
    bumpBoard();
    return false;
  }
  const {ox,oy}=origin;
  placeAt(ox,oy,piece);
  if(typeof idx==='number') tray.splice(idx,1);
  selected=null;
  clearPreviewAll();
  if(tray.length===0){ refillTray(); } else { renderTray(); }
  checkGameOver();
  return true;
}

function bumpBoard(){
  boardEl.classList.remove('shake'); void boardEl.offsetWidth; boardEl.classList.add('shake');
}

function checkGameOver(){
  const anyFit = tray.length && tray.some(p=>{
    for(let y=0;y<BOARD;y++) for(let x=0;x<BOARD;x++) if(canPlaceAt(x,y,p.shape)) return true;
    return false;
  });
  if(tray.length && !anyFit){ finalScoreEl.textContent=score; gameOverEl.classList.add('show'); }
}

/* controls */
document.getElementById('resetBtn').onclick=()=>start();
document.getElementById('againBtn').onclick=()=>{ gameOverEl.classList.remove('show'); start(); };

/* boot */
function start(){
  score=0;
  scoreEl.textContent=score;
  selected=null;
  isClearing=false;
  clearPreviewAll();
  boardEl.classList.remove('dragging');
  buildBoard(); newGrid(); clearPendingAnchor(); refillTray();
  scheduleResponsiveSize();
}
start();

window.addEventListener('resize', scheduleResponsiveSize);
window.addEventListener('orientationchange', scheduleResponsiveSize);
</script>
</body>
</html>
