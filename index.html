<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>1010 — Minimal</title>
  <meta name="theme-color" content="#F8F7F5" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#111213" media="(prefers-color-scheme: dark)">
  <link rel="manifest" href="manifest.json">
  <style>
    :root{
      --bg:#F8F7F5;           /* warm off-white */
      --bg-elev:#FFFFFF;      /* card */
      --grid:#E7E4DF;         /* subtle grid lines */
      --tile:#57606A;         /* slate block */
      --tile-ghost:rgba(139,148,158,0.4); /* ghost 40% */
      --accent:#9AB8A4;       /* your accent */
      --text:#111213;
      --muted:#6b7280;
      --shadow: 0 8px 24px rgba(17,18,19,0.08);
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0E0F10;
        --bg-elev:#151718;
        --grid:#2A2C2E;
        --tile:#D6D8DB;
        --tile-ghost:rgba(214,216,219,0.35);
        --accent:#9AB8A4;
        --text:#EDEEF0;
        --muted:#A0A6AE;
        --shadow: 0 8px 24px rgba(0,0,0,0.45);
      }
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color: transparent}
    html,body{height:100%}
    body{
      margin:0; font:16px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg); color:var(--text);
      display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px;
    }
    .topbar{width:100%; max-width:520px; display:flex; align-items:center; justify-content:space-between; padding:8px 6px;}
    .btn{border:none; background:var(--bg-elev); color:var(--text); padding:10px 14px; border-radius:12px; box-shadow:var(--shadow);
      font-size:14px; cursor:pointer;}
    .btn:active{transform:translateY(1px)}
    .score{font-weight:600; font-size:16px}
    .wrap{width:100%; max-width:520px; display:flex; flex-direction:column; align-items:center; gap:12px}
    .board{
      position:relative; width:100%; aspect-ratio:1/1; background:var(--bg-elev); border-radius:16px; box-shadow:var(--shadow); padding:10px;
      display:grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(10, 1fr); gap:2px;
    }
    .cell{ background:transparent; border:1px solid var(--grid); border-radius:4px; }
    .tile{ position:absolute; pointer-events:none; }
    .tile .b{position:absolute; width:100%; height:100%; background:var(--tile); border-radius:4px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.12)}
    .tile.ghost .b{ background:var(--tile-ghost); box-shadow:none }
    .tray{ width:100%; display:flex; align-items:center; justify-content:center; gap:12px }
    .piece{ position:relative; background:var(--bg-elev); border-radius:12px; box-shadow:var(--shadow); padding:12px; min-width:96px; min-height:96px; display:grid; place-items:center; touch-action:none; cursor:grab;}
    .piece:active{cursor:grabbing}
    .piece-inner{ position:relative; width:80px; height:80px }
    .meta{ width:100%; max-width:520px; display:flex; align-items:center; justify-content:space-between; gap:8px }
    .toggle{display:flex; align-items:center; gap:8px; font-size:14px}
    .switch{ appearance:none; width:44px; height:28px; border-radius:999px; background:#cbd5e1; position:relative; outline:none; cursor:pointer }
    .switch:checked{ background:var(--accent) }
    .switch::after{ content:""; position:absolute; top:3px; left:3px; width:22px; height:22px; border-radius:50%; background:#fff; transition:left .15s ease }
    .switch:checked::after{ left:19px }
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; padding:24px }
    .modal.show{ display:flex }
    .sheet{ background:var(--bg-elev); color:var(--text); width:100%; max-width:380px; border-radius:16px; box-shadow:var(--shadow); padding:20px; text-align:center }
    .sheet h2{ margin:0 0 8px 0 }
    .sheet p{ margin:0 0 16px 0; color:var(--muted) }
    .clear-sweep{ position:absolute; background:var(--accent); opacity:0.14; animation:sweep .22s ease-out forwards }
    @keyframes sweep{ from{opacity:0.22} to{opacity:0} }
  </style>
</head>
<body>
  <div class="topbar">
    <button class="btn" id="resetBtn">Reset</button>
    <div class="score">Score: <span id="score">0</span></div>
    <button class="btn" id="moreBtn">⋯</button>
  </div>

  <div class="wrap">
    <div id="board" class="board" aria-label="game board" role="grid"></div>
    <div class="tray" id="tray" aria-label="piece tray"></div>

    <div class="meta">
      <label class="toggle"><input type="checkbox" id="soundToggle" class="switch" /> Sound</label>
      <label class="toggle"><input type="checkbox" id="contrastToggle" class="switch" /> High contrast</label>
    </div>
  </div>

  <div class="modal" id="gameOver">
    <div class="sheet">
      <h2>Game Over</h2>
      <p>Final score: <span id="finalScore">0</span></p>
      <button class="btn" id="againBtn">Play again</button>
    </div>
  </div>

  <audio id="sndPlace" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <audio id="sndClear" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAZGF0YQAAAAA=" type="audio/wav">
  </audio>

  <script>
  // ===== Utility =====
  const qs = s=>document.querySelector(s);
  const qsa = s=>Array.from(document.querySelectorAll(s));
  function rnd(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // ===== Game State =====
  const BOARD_SIZE = 10;
  const CELL = 1; const EMPTY = 0;
  let grid = [];              // 2D array
  let score = 0;
  let tray = [];              // 3 pieces
  let dragging = null;        // {shape, el, ghost, originIdx}
  let cellSize = 0;           // px per cell on board
  let soundsOn = false;

  // Shapes are arrays of [x,y] offsets. Fixed set; random forever (no difficulty ramp).
  const SHAPES = [
    [[0,0]],                                  // single
    [[0,0],[1,0]],                            // 2-line
    [[0,0],[1,0],[2,0]],                      // 3-line
    [[0,0],[1,0],[2,0],[3,0]],                // 4-line
    [[0,0],[1,0],[2,0],[3,0],[4,0]],          // 5-line
    [[0,0],[1,0],[0,1],[1,1]],                // 2x2
    [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2]], // 3x3
    [[0,0],[0,1],[0,2],[1,2]],                // L3
    [[0,0],[1,0],[2,0],[1,1]],                // T3
    [[0,0],[1,0],[1,1],[2,1]],                // S 2x3
    [[0,0],[0,1],[1,1]],                      // small corner
    [[0,0],[1,0],[2,0],[2,1]],                // L4
  ];

  // ===== Init UI refs =====
  const boardEl = qs('#board');
  const trayEl  = qs('#tray');
  const scoreEl = qs('#score');
  const gameOverEl = qs('#gameOver');
  const finalScoreEl = qs('#finalScore');
  const sndPlace = qs('#sndPlace');
  const sndClear = qs('#sndClear');

  function buildBoard(){
    boardEl.innerHTML = '';
    for (let i=0;i<BOARD_SIZE*BOARD_SIZE;i++){
      const c = document.createElement('div');
      c.className='cell';
      boardEl.appendChild(c);
    }
    const rect = boardEl.getBoundingClientRect();
    const gap = 2; const pad = 10; // match CSS
    cellSize = (rect.width - pad*2 - gap*9) / 10;
  }

  function newGrid(){
    grid = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(EMPTY));
  }

  function updateScore(delta){
    score += delta; scoreEl.textContent = score;
  }

  // ===== Tray & Pieces =====
  function dealPiece(){ return {shape: JSON.parse(JSON.stringify(rnd(SHAPES)))} }

  function refillTray(){
    tray = [dealPiece(), dealPiece(), dealPiece()];
    renderTray();
  }

  function renderTray(){
    trayEl.innerHTML = '';
    tray.forEach((p,idx)=>{
      const card = document.createElement('div');
      card.className='piece'; card.setAttribute('data-idx', idx);
      const inner = document.createElement('div'); inner.className='piece-inner';
      card.appendChild(inner); trayEl.appendChild(card);
      drawShape(inner, p.shape, 12, 12);
      attachDrag(card, p.shape, idx);
    });
  }

  function drawShape(container, shape, bx=0, by=0){
    const xs = shape.map(s=>s[0]); const ys = shape.map(s=>s[1]);
    const w = Math.max(...xs)+1; const h = Math.max(...ys)+1;
    const unit = Math.min((container.clientWidth - bx)/w, (container.clientHeight - by)/h);
    const offX = (container.clientWidth - w*unit)/2; const offY = (container.clientHeight - h*unit)/2;
    shape.forEach(([x,y])=>{
      const b = document.createElement('div'); b.className='b';
      b.style.left = (offX + x*unit)+'px'; b.style.top=(offY + y*unit)+'px';
      b.style.width= unit+'px'; b.style.height= unit+'px';
      container.appendChild(b);
    });
  }

  // ===== Drag & Place =====
  function attachDrag(card, shape, idx){
    let startX=0, startY=0; let tileEl=null;

    const start=(x,y)=>{
      tileEl = document.createElement('div'); tileEl.className='tile';
      document.body.appendChild(tileEl);
      const ghost = document.createElement('div'); ghost.className='tile ghost'; document.body.appendChild(ghost);
      tileEl._ghost = ghost;
      shape.forEach(()=>{ const b=document.createElement('div'); b.className='b'; tileEl.appendChild(b); const g=document.createElement('div'); g.className='b'; ghost.appendChild(g); });
      dragging = {shape: JSON.parse(JSON.stringify(shape)), el: tileEl, ghost, originIdx: idx};
      move(x,y);
    };

    const move=(x,y)=>{
      if(!dragging) return;
      const t = dragging.el; const g = dragging.ghost;
      t.style.left=(x-20)+'px'; t.style.top=(y-20)+'px';
      g.style.left=(x-20)+'px'; g.style.top=(y-20)+'px';
      const {gx, gy} = computeSnap(x,y, dragging.shape);
      positionBlocks(g, gx, gy, dragging.shape, true);
    };

    const end=(x,y)=>{
      if(!dragging) return;
      const {gx, gy, fits} = computeSnap(x,y, dragging.shape);
      if(fits){
        placeShape(gx, gy, dragging.shape);
        removeTrayPiece(dragging.originIdx);
        playTick();
        postPlace();
      }
      dragging.el.remove(); dragging.ghost.remove(); dragging=null;
    };

    // Mouse
    card.addEventListener('mousedown', e=>{ startX=e.clientX; startY=e.clientY; start(e.clientX,e.clientY); e.preventDefault();});
    window.addEventListener('mousemove', e=>{ if(dragging) move(e.clientX,e.clientY); });
    window.addEventListener('mouseup', e=>{ if(dragging) end(e.clientX,e.clientY); });
    // Touch
    card.addEventListener('touchstart', e=>{ const t=e.touches[0]; start(t.clientX,t.clientY); }, {passive:true});
    card.addEventListener('touchmove', e=>{ if(!dragging) return; const t=e.touches[0]; move(t.clientX,t.clientY); }, {passive:true});
    card.addEventListener('touchend', e=>{ const t=e.changedTouches[0]||{clientX:startX,clientY:startY}; end(t.clientX,t.clientY); }, {passive:true});
  }

  function positionBlocks(container, gx, gy, shape){
    const bs = container.querySelectorAll('.b');
    shape.forEach(([sx,sy],i)=>{
      const x = gx + sx; const y = gy + sy;
      const left = boardEl.offsetLeft + 10 + x*(cellSize+2);
      const top  = boardEl.offsetTop  + 10 + y*(cellSize+2);
      const b = bs[i]; b.style.position='absolute'; b.style.left=left+'px'; b.style.top=top+'px'; b.style.width=cellSize+'px'; b.style.height=cellSize+'px';
    });
  }

  function computeSnap(px,py, shape){
    const r = boardEl.getBoundingClientRect();
    const x = Math.floor((px - r.left - 10) / (cellSize+2));
    const y = Math.floor((py - r.top  - 10) / (cellSize+2));
    let fits = canPlace(x,y,shape);
    return {gx:x, gy:y, fits};
  }

  function canPlace(x,y,shape){
    return shape.every(([sx,sy])=>{
      const cx=x+sx, cy=y+sy;
      return cx>=0 && cy>=0 && cx<BOARD_SIZE && cy<BOARD_SIZE && grid[cy][cx]===EMPTY;
    });
  }

  function placeShape(x,y,shape){
    shape.forEach(([sx,sy])=>{
      grid[y+sy][x+sx]=CELL;
    });
    updateScore(shape.length);
    renderBoardTiles();
  }

  function renderBoardTiles(){
    // Remove existing absolute tiles and redraw based on grid
    qsa('.board .b').forEach(el=>el.parentElement.remove());
    for(let yy=0; yy<BOARD_SIZE; yy++){
      for(let xx=0; xx<BOARD_SIZE; xx++){
        if(grid[yy][xx]===CELL){
          const t = document.createElement('div'); t.className='tile'; boardEl.appendChild(t);
          const b = document.createElement('div'); b.className='b'; t.appendChild(b);
          const left = 10 + xx*(cellSize+2); const top = 10 + yy*(cellSize+2);
          t.style.left=left+'px'; t.style.top=top+'px'; b.style.width=cellSize+'px'; b.style.height=cellSize+'px';
        }
      }
    }
  }

  function removeTrayPiece(idx){
    tray[idx]=null;
    if(tray.every(p=>p===null)) refillTray(); else renderTray();
  }

  function postPlace(){
    const rowsToClear = [];
    const colsToClear = [];
    for(let y=0;y<BOARD_SIZE;y++) if(grid[y].every(v=>v===CELL)) rowsToClear.push(y);
    for(let x=0;x<BOARD_SIZE;x++){
      let full=true; for(let y=0;y<BOARD_SIZE;y++){ if(grid[y][x]!==CELL){ full=false; break; } }
      if(full) colsToClear.push(x);
    }

    if(rowsToClear.length || colsToClear.length){
      // matcha sweep
      rowsToClear.forEach(y=>{
        const sweep = document.createElement('div'); sweep.className='clear-sweep';
        sweep.style.left='10px'; sweep.style.top=(10 + y*(cellSize+2))+'px';
        sweep.style.width=(10*cellSize + 9*2)+'px'; sweep.style.height=cellSize+'px';
        boardEl.appendChild(sweep); setTimeout(()=>sweep.remove(), 240);
      });
      colsToClear.forEach(x=>{
        const sweep = document.createElement('div'); sweep.className='clear-sweep';
        sweep.style.top='10px'; sweep.style.left=(10 + x*(cellSize+2))+'px';
        sweep.style.height=(10*cellSize + 9*2)+'px'; sweep.style.width=cellSize+'px';
        boardEl.appendChild(sweep); setTimeout(()=>sweep.remove(), 240);
      });

      const cleared = rowsToClear.length + colsToClear.length;
      rowsToClear.forEach(y=> grid[y]=Array(BOARD_SIZE).fill(EMPTY));
      colsToClear.forEach(x=>{ for(let y=0;y<BOARD_SIZE;y++) grid[y][x]=EMPTY; });
      updateScore(cleared*10);
      renderBoardTiles();
      playClear();
    }

    // game over?
    const remaining = tray.filter(Boolean);
    if(remaining.length){
      const anyFit = remaining.some(p=> pieceHasFit(p.shape));
      if(!anyFit){ showGameOver(); }
    }
  }

  function pieceHasFit(shape){
    for(let y=0;y<BOARD_SIZE;y++){
      for(let x=0;x<BOARD_SIZE;x++){
        if(canPlace(x,y,shape)) return true;
      }
    }
    return false;
  }

  function showGameOver(){
    finalScoreEl.textContent = score;
    gameOverEl.classList.add('show');
  }

  // ===== Sound (off by default) =====
  function playTick(){ if(soundsOn) { try{sndPlace.currentTime=0; sndPlace.play()}catch{}} }
  function playClear(){ if(soundsOn) { try{sndClear.currentTime=0; sndClear.play()}catch{}} }

  // ===== Controls =====
  qs('#resetBtn').onclick = ()=>{ startGame(); };
  qs('#againBtn').onclick = ()=>{ gameOverEl.classList.remove('show'); startGame(); };
  qs('#soundToggle').onchange = (e)=>{ soundsOn = e.target.checked; };
  qs('#contrastToggle').onchange = (e)=>{
    document.body.classList.toggle('hi-con', e.target.checked);
    if(e.target.checked){ document.documentElement.style.setProperty('--grid', 'rgba(0,0,0,0.35)'); }
    else { document.documentElement.style.setProperty('--grid', getComputedStyle(document.documentElement).getPropertyValue('--grid')); }
  };

  function startGame(){
    gameOverEl.classList.remove('show');
    score = 0; updateScore(0);
    newGrid(); buildBoard(); renderBoardTiles(); refillTray();
  }

  // Start
  window.addEventListener('resize', ()=>{ buildBoard(); renderBoardTiles(); });
  startGame();

  // ===== PWA support =====
  if('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');
  </script>
</body>
</html>
