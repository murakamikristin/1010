<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<meta name="theme-color" content="#F4F1EB" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
<link rel="manifest" href="manifest.webmanifest" />
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Sixtyfour&family=Coiny&family=Major+Mono+Display&display=swap" rel="stylesheet" />
<title>1010 — Minimal</title>
<style>
  :root{
    --bg:#F4F1EB;
    --board:var(--bg);
    --tile:#FFFFFF;
    --block:#57606A;
    --text:#8A8172;
    --shadow:0 14px 45px rgba(39,36,29,.12);
    --max-width:520px;
    --board-size:520px;
    --cell-radius:10px;
    --pip-radius:7px;
    --grid-gap:5px;
    --tray-slot-height:150px;
  }
  @media (max-height: 760px){
    body{ gap:clamp(20px,4vh,28px); padding-top:18px; padding-bottom:18px; }
    .wrap{ gap:clamp(22px,5vh,32px); }
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#050506;
      --board:var(--bg);
      --tile:#0E1012;
      --block:#8B96A3;
      --text:#E0E3EA;
      --shadow:0 18px 40px rgba(0,0,0,.65);
    }
    .palette-panel{
      background:rgba(14,15,16,.92);
      border-color:rgba(255,255,255,.08);
    }
  }

  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font:500 18px/1.45 "Inter", system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    gap:32px;
    padding:28px clamp(8px,3vw,16px) 20px;
    min-height:100vh;
    min-height:100dvh;
    user-select:none;
    -webkit-user-select:none;
    touch-action:manipulation;
    -webkit-touch-callout:none;
    overflow:hidden;
    overscroll-behavior:none;
  }
  .wrap,
  .board,
  .tray,
  .piece,
  .piece-inner,
  .topbar{
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
    -webkit-touch-callout:none;
  }

  .topbar{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    position:relative;
    z-index:30;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    gap:clamp(12px,3vw,20px);
    letter-spacing:.2px;
    color:var(--text);
  }
  .topbar.frozen{
    opacity:0;
    pointer-events:none;
    visibility:hidden;
  }

  .btn{
    background:transparent;
    border:none;
    font-weight:600;
    font-size:clamp(16px,4vw,20px);
    color:var(--text);
    cursor:pointer;
    padding:0;
  }
  .btn:active{opacity:.7}
  .score{
    font-family:'Major Mono Display', 'Coiny', system-ui, sans-serif;
    font-size:clamp(28px,6vw,36px);
    letter-spacing:.16em;
    color:var(--text);
    min-width:clamp(68px,13vw,110px);
    text-align:center;
    padding:0 6px;
  }
  .score-board{
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    width:100%;
    gap:clamp(18px,5vw,30px);
    padding:0 clamp(28px,8vw,40px);
  }
  .score-slot{
    flex:1 1 0;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .score-slot.left{ justify-content:flex-end; }
  .score-slot.right{ justify-content:flex-start; }
  .score-divider-wrap{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    pointer-events:none;
  }
  .score-divider{
    width:clamp(28px,7vw,36px);
    height:clamp(28px,7vw,36px);
    stroke:var(--text);
    fill:currentColor;
    opacity:.7;
  }
  .icon-group{display:flex;align-items:center;gap:clamp(14px,4vw,20px);flex:0 0 auto;}
  .top-actions{
    display:flex;
    align-items:center;
    justify-content:space-between;
    width:100%;
  }
  .glass-btn{width:clamp(48px,12vw,56px);height:clamp(48px,12vw,56px);border-radius:18px;border:1px solid rgba(255,255,255,.6);background:rgba(255,255,255,.35);backdrop-filter:blur(20px);box-shadow:0 10px 28px rgba(0,0,0,.12);display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--text);position:relative;overflow:hidden;}
  .glass-btn::after{content:'';position:absolute;inset:6%;border-radius:inherit;border:1px solid rgba(255,255,255,.7);opacity:.4;pointer-events:none;}
  .glass-btn svg{width:clamp(22px,6vw,26px);height:clamp(22px,6vw,26px);stroke:currentColor;}

  .wrap{
    width:100%;
    max-width:var(--max-width);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:clamp(38px,8vw,60px);
  }

  .board{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    aspect-ratio:1/1;
    background:var(--board);
    display:grid;
    grid-template-columns:repeat(10,1fr);
    grid-template-rows:repeat(10,1fr);
    gap:var(--grid-gap);
    padding:clamp(8px,2.4vw,16px);
    border-radius:18px;
    box-shadow:none;
  }
  .board.dragging{
    box-shadow:none;
  }
  .cell{
    position:relative;
    overflow:hidden;
    background:var(--tile);
    border-radius:var(--cell-radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    transition:none;
  }
  .cell.filled{
    background:var(--cell-fill, var(--block));
    box-shadow:none;
  }
  .cell.preview{
    box-shadow:none;
  }
  .cell.clearing{
    animation:clearSentinel .35s ease forwards;
    animation-delay:var(--clear-delay,0s);
  }
  .cell.clearing::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:inherit;
    background:var(--block);
    animation:cascadeClear .35s ease forwards;
    animation-delay:var(--clear-delay,0s);
  }
  @keyframes clearSentinel{
    0%{opacity:1;}
    100%{opacity:1;}
  }
  @keyframes cascadeClear{
    0%{transform:scale(1);opacity:1;}
    100%{transform:translateY(-10px);opacity:0;}
  }
  .tray{
    width:min(100%, var(--board-size, 100%));
    max-width:var(--max-width);
    margin:0 auto;
    display:flex;
    align-items:stretch;
    justify-content:space-between;
    gap:var(--piece-gap, clamp(8px, 2vw, 18px));
    overflow:visible;
  }
  .piece{
    flex:1 1 0;
    min-width:0;
    background:transparent;
    border:none;
    border-radius:16px;
    padding:12px 0;
    cursor:grab;
    box-shadow:none;
    transition:transform .2s ease;
    touch-action:none;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:var(--tray-slot-height, 150px);
    height:var(--tray-slot-height, 150px);
    overflow:visible;
    position:relative;
  }
  .piece:active{cursor:grabbing}
  .piece.dragging{
    visibility:hidden;
  }
  .piece.empty{
    visibility:hidden;
    pointer-events:none;
  }
  .piece-overlay{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    pointer-events:none;
  }
  .drag-ghost,
  .pointer-ghost{
    position:fixed;
    top:0;
    left:0;
    pointer-events:none;
    z-index:1000;
    transform:translate(-9999px,-9999px);
    will-change:transform;
  }
  .drag-ghost{
    z-index:-1;
  }
  .piece-inner{
    display:grid;
    gap:var(--grid-gap);
    justify-items:stretch;
    align-items:stretch;
  }
  .drag-ghost{
    position:fixed;
    top:-9999px;
    left:-9999px;
    pointer-events:none;
    z-index:0;
  }

  .palette-wrap{position:relative; display:flex;}
  .palette-btn{width:clamp(48px,12vw,56px);height:clamp(48px,12vw,56px);border-radius:18px;border:1px solid rgba(255,255,255,.6);background:rgba(255,255,255,.35);backdrop-filter:blur(20px);box-shadow:0 10px 28px rgba(0,0,0,.12);display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--text);position:relative;overflow:hidden;}
  .palette-btn::after{content:'';position:absolute;inset:6%;border-radius:inherit;border:1px solid rgba(255,255,255,.7);opacity:.4;pointer-events:none;}
  .palette-btn svg{width:clamp(22px,6vw,26px);height:clamp(22px,6vw,26px);stroke:currentColor;}
  .palette-panel{
    position:absolute;
    top:calc(100% + 10px);
    left:0;
    transform:none;
    display:none;
    flex-direction:column;
    gap:6px;
    background:rgba(255,255,255,1);
    border-radius:14px;
    padding:12px;
    box-shadow:0 12px 30px rgba(0,0,0,.12);
    border:1px solid rgba(0,0,0,.04);
    z-index:60;
  }
  .palette-panel.show{display:flex;}
  .palette-option{
    display:flex;
    align-items:center;
    justify-content:flex-start;
    gap:6px;
    padding:6px 8px;
    border-radius:10px;
    border:none;
    background:transparent;
    cursor:pointer;
  }
  .palette-option:hover{background:rgba(0,0,0,.05);}
  .palette-option.active{background:rgba(0,0,0,.08);}
  .palette-swatch{
    display:flex;
    gap:4px;
    align-items:center;
  }
  .palette-dot{
    width:18px;
    height:18px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.1);
  }

  .b{
    width:100%;
    height:100%;
    background:var(--block);
    border-radius:var(--pip-radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.18);
  }

  /* modal */
  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; padding:24px }
  .modal.show{ display:flex }
  .sheet{ background:#fff; color:var(--text); width:100%; max-width:420px; border-radius:24px; padding:28px; text-align:center; box-shadow:0 30px 80px rgba(0,0,0,.18); }
  .sheet h2{ margin:0 0 16px 0; font-family:'Sixtyfour', system-ui, sans-serif; font-size:clamp(28px,8vw,36px); letter-spacing:1px; white-space:nowrap; }
  .score-grid{ display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:14px; margin:0 0 20px 0; text-transform:uppercase; font-size:14px; letter-spacing:1px; }
  .score-grid.single{ grid-template-columns:1fr; text-transform:none; }
  .score-box{ background:transparent; border-radius:18px; padding:14px; }
  .score-box span{ display:block; opacity:.6; margin-bottom:10px; }
  .score-box strong{ display:block; font-family:'Major Mono Display', 'Coiny', system-ui, sans-serif; font-size:clamp(38px,9vw,50px); font-weight:700; color:var(--text); text-transform:none; letter-spacing:.2em; }
  .sheet .btn{
    font-family:'Sixtyfour', system-ui, sans-serif;
    font-size:clamp(18px,6vw,22px);
    text-transform:uppercase;
    width:100%;
    padding:14px 0;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.6);
    background:rgba(255,255,255,.35);
    backdrop-filter:blur(18px);
    box-shadow:0 10px 28px rgba(0,0,0,.12);
  }
</style>
</head>
<body>
  <div class="topbar" id="topbar">
    <div class="top-actions">
      <div class="icon-group">
        <div class="palette-wrap">
          <button class="palette-btn" id="paletteBtn" aria-label="Change block colors">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 3c-4.97 0-9 3.4-9 8s4.03 8 9 8c.956 0 1.836-.094 2.632-.266 1.125-.246 1.868.915 1.368 1.966-.402.848.73 1.552 1.45.964A8 8 0 0 0 21 14c0-4.6-4.03-7-9-7Z"/>
              <circle cx="8.2" cy="8" r="1.1" fill="var(--bg)"/>
              <circle cx="11.3" cy="7" r="1.1" fill="var(--bg)"/>
              <circle cx="14.2" cy="9.8" r="1.1" fill="var(--bg)"/>
              <circle cx="9.8" cy="11.1" r="1.1" fill="var(--bg)"/>
            </svg>
          </button>
          <div class="palette-panel" id="palettePanel" aria-label="Color options"></div>
        </div>
      </div>
      <div class="icon-group">
        <button class="glass-btn" id="resetBtn" aria-label="Reset game">
          <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
            <path d="M3 4v6h6"></path>
            <path d="M21 20v-6h-6"></path>
            <path d="M5.64 17.66a9 9 0 0 0 12.73 0L21 15"></path>
            <path d="M3 9l2.64-2.66a9 9 0 0 1 12.73 0L21 9"></path>
          </svg>
        </button>
      </div>
    </div>
    <div class="score-board">
      <div class="score-slot left">
        <div class="score" id="score">0</div>
      </div>
      <div class="score-divider-wrap">
        <svg class="score-divider" viewBox="0 0 24 24" stroke-width="1.6">
          <path d="M12 17a5 5 0 1 0 0-10 5 5 0 0 0 0 10Z" fill="currentColor"/>
          <path d="M12 2v2M12 20v2M4 12H2m20 0h-2M5.636 5.636 4.222 4.222m15.556 0-1.414 1.414m0 12.728 1.414 1.414M4.222 19.778l1.414-1.414" stroke-linecap="round" fill="none"/>
        </svg>
      </div>
      <div class="score-slot right">
        <div class="score" id="topScore">0</div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div id="board" class="board" aria-label="game board" role="grid"></div>
    <div class="tray" id="tray" aria-label="piece tray"></div>
  </div>

  <div class="modal" id="gameOver">
    <div class="sheet">
      <h2>Game Over</h2>
      <div class="score-grid single">
        <div class="score-box">
          <strong id="finalScore">0</strong>
        </div>
      </div>
      <button class="btn" id="againBtn">Play again</button>
    </div>
  </div>

<script>
/* ------- Minimal 1010 (drag-and-drop) ------- */
const BOARD=10, EMPTY=0;
const CLEAR_DELAY_STEP_MS=50;
const TRAY_SCALE=0.64;
const MIN_TRAY_CELL=15;
const MIN_TRAY_GAP=3;
const STORAGE_KEYS={palette:'1010-palette', state:'1010-state', best:'1010-best'};
const PALETTES=[
  {id:'slate-mix', name:'Slate — Mix', colors:['#3E4349','#57606A','#9CA3AF'], mode:'mix'},
  {id:'slate-single', name:'Slate — Single', colors:['#57606A'], mode:'single'},
  {id:'blue-mix', name:'Blue — Mix', colors:['#2B3A55','#5E81AC','#BFD7EA'], mode:'mix'},
  {id:'blue-single', name:'Blue — Single', colors:['#5E81AC'], mode:'single'},
  {id:'sage-mix', name:'Sage — Mix', colors:['#495A4E','#7E8F83','#C9D4CA'], mode:'mix'},
  {id:'sage-single', name:'Sage — Single', colors:['#7E8F83'], mode:'single'},
  {id:'sand-mix', name:'Sand — Mix', colors:['#5C5346','#A89885','#D8CFC1'], mode:'mix'},
  {id:'sand-single', name:'Sand — Single', colors:['#A89885'], mode:'single'}
];
let grid, score=0, tray=new Array(3).fill(null), selected=null;
let boardCellSize=0, boardGap=8, isClearing=false;
let pendingAnchor=null, pendingAnchorIdx=null;
let pendingAnchorRect=null;
let currentPreview=null;
let draggingPiece=false;
let resizeScheduled=false;
let currentBoardPixels=0;
let pointerDragId=null;
let pointerCaptureTarget=null;
let dragGhost=null;
let pointerGhost=null;
let pointerAnchorOffset={x:0,y:0};
let palettePanelOpen=false;
let currentPaletteId=PALETTES[0].id;
let bestScore=0;

const ZERO_ANCHOR=()=>({dx:0,dy:0});

function getCurrentPalette(){
  return PALETTES.find(p=>p.id===currentPaletteId) || PALETTES[0];
}

function pickPieceColor(){
  const palette=getCurrentPalette();
  if(!palette || !Array.isArray(palette.colors) || !palette.colors.length){
    const fallback=getComputedStyle(document.documentElement).getPropertyValue('--block') || '#57606A';
    return fallback.trim();
  }
  if(palette.mode==='single'){
    return palette.colors[0];
  }
  const colors=palette.colors;
  return colors[Math.floor(Math.random()*colors.length)];
}

function assignPieceColor(piece){
  if(!piece) return piece;
  piece.color=pickPieceColor();
  return piece;
}

function cloneShape(shape){
  if(!Array.isArray(shape)) return [];
  return shape.map(point=>Array.isArray(point)?[point[0],point[1]]:[0,0]);
}

function clonePiece(piece){
  if(!piece) return null;
  return {
    shape:cloneShape(piece.shape),
    color:piece.color || pickPieceColor()
  };
}

function saveGameState(){
  if(!grid || !Array.isArray(tray)) return;
  const state={
    score,
    grid:grid.map(row=>row.slice()),
    tray:tray.map(clonePiece)
  };
  try{
    localStorage.setItem(STORAGE_KEYS.state, JSON.stringify(state));
  }catch(err){}
}

function clearSavedGame(){
  try{
    localStorage.removeItem(STORAGE_KEYS.state);
  }catch(err){}
}

function restoreSavedGame(){
  let raw=null;
  try{
    raw=localStorage.getItem(STORAGE_KEYS.state);
  }catch(err){
    raw=null;
  }
  if(!raw) return false;
  let data=null;
  try{
    data=JSON.parse(raw);
  }catch(err){
    data=null;
  }
  if(!data || typeof data.score!=='number' || !Array.isArray(data.grid) || data.grid.length!==BOARD) return false;
  grid=data.grid.map(row=>Array.isArray(row)?row.slice(0,BOARD):Array(BOARD).fill(EMPTY));
  tray=new Array(3).fill(null);
  if(Array.isArray(data.tray)){
    for(let i=0;i<Math.min(3,data.tray.length);i++){
      const piece=data.tray[i];
      if(piece && Array.isArray(piece.shape)){
        tray[i]={shape:cloneShape(piece.shape), color:piece.color || pickPieceColor()};
      }
    }
  }
  score=data.score;
  scoreEl.textContent=score;
  updateBoardCells();
  renderTray();
  return true;
}

function getSelectedAnchor(){
  return (selected && selected.anchor) ? selected.anchor : ZERO_ANCHOR();
}

function buildPlacementOffsets(shape){
  const anchor=getSelectedAnchor();
  const offsets=[];
  const seen=new Set();
  const add=(dx,dy)=>{
    const key=`${dx},${dy}`;
    if(!seen.has(key)){ seen.add(key); offsets.push({dx,dy}); }
  };
  add(anchor.dx, anchor.dy);
  shape.forEach(([dx,dy])=>add(dx,dy));
  return offsets;
}

function findPlacementOrigin(x,y){
  if(!selected || !selected.shape || !Number.isFinite(x) || !Number.isFinite(y)) return null;
  const shape=selected.shape;
  const offsets=buildPlacementOffsets(shape);
  for(const off of offsets){
    const ox=x-off.dx, oy=y-off.dy;
    if(canPlaceAt(ox,oy,shape)) return {ox,oy};
  }
  return null;
}

function computeBoardPixels(){
  const rootStyles=getComputedStyle(document.documentElement);
  const maxWidth=parseFloat(rootStyles.getPropertyValue('--max-width')) || 520;
  const vw=Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
  const bodyStyles=getComputedStyle(document.body);
  const horizontalPadding=parseFloat(bodyStyles.paddingLeft)+parseFloat(bodyStyles.paddingRight);
  const verticalPadding=parseFloat(bodyStyles.paddingTop)+parseFloat(bodyStyles.paddingBottom);
  const topbar=document.querySelector('.topbar');
  const wrap=document.querySelector('.wrap');
  const topHeight=topbar?topbar.offsetHeight:0;
  const wrapGap=wrap?parseFloat(getComputedStyle(wrap).gap)||0:0;
  const trayHeight=trayEl?trayEl.offsetHeight:0;
  let availableWidth=Math.min(maxWidth, vw-horizontalPadding);
  availableWidth=Math.max(200, availableWidth);
  let availableHeight=window.innerHeight - (verticalPadding + topHeight + wrapGap + trayHeight + 40);
  if(!Number.isFinite(availableHeight) || availableHeight<=0) availableHeight=availableWidth;
  let size=Math.min(availableWidth, availableHeight);
  return Math.max(220, size);
}

function applyBoardSize(){
  const size=computeBoardPixels();
  if(Math.abs(size-currentBoardPixels)<=1) return;
  currentBoardPixels=size;
  document.documentElement.style.setProperty('--board-size', size+'px');
  window.requestAnimationFrame(()=>{ recomputeBoardMetrics(); });
}

function scheduleResponsiveSize(){
  if(resizeScheduled) return;
  resizeScheduled=true;
  window.requestAnimationFrame(()=>{
    resizeScheduled=false;
    applyBoardSize();
    setTimeout(applyBoardSize, 80);
  });
}

function recomputeBoardMetrics(){
  const someCell=boardEl.firstElementChild;
  if(!someCell) return;
  const newSize=Math.round(someCell.getBoundingClientRect().width);
  if(!newSize || newSize===boardCellSize) return;
  boardCellSize=newSize;
  const gapPx=Math.max(2, Math.min(6, boardCellSize*0.05));
  boardGap=gapPx;
  document.documentElement.style.setProperty('--grid-gap', gapPx+'px');
  const trayGap=Math.max(8, gapPx*2);
  trayEl.style.setProperty('--piece-gap', trayGap+'px');
  const radius=Math.max(4, Math.min(10, boardCellSize*0.08));
  document.documentElement.style.setProperty('--cell-radius', radius+'px');
  document.documentElement.style.setProperty('--pip-radius', radius+'px');
  const slotHeight=Math.max(150, Math.min(260, boardCellSize*3.2));
  document.documentElement.style.setProperty('--tray-slot-height', slotHeight+'px');
  renderTray();
}

const SHAPES=[
  [[0,0]],
  [[0,0],[1,0]], [[0,0],[0,1]],
  [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
  [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
  [[0,0],[1,0],[2,0],[3,0],[4,0]], [[0,0],[0,1],[0,2],[0,3],[0,4]],
  [[0,0],[1,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2]],
  [[0,0],[0,1],[0,2],[1,2]],
  [[0,0],[1,0],[2,0],[1,1]],
  [[0,0],[1,0],[1,1],[2,1]],
  [[0,0],[0,1],[1,1],[1,2]],
  [[0,0],[0,1],[1,1]],
  [[0,0],[1,0],[2,0],[2,1]],
];

const topbarEl=document.getElementById('topbar');
const boardEl=document.getElementById('board');
const trayEl=document.getElementById('tray');
const scoreEl=document.getElementById('score');
const topScoreEl=document.getElementById('topScore');
const gameOverEl=document.getElementById('gameOver');
const finalScoreEl=document.getElementById('finalScore');
const paletteBtn=document.getElementById('paletteBtn');
const palettePanel=document.getElementById('palettePanel');

function buildPalettePanel(){
  if(!palettePanel) return;
  palettePanel.innerHTML='';
  PALETTES.forEach(palette=>{
    const btn=document.createElement('button');
    btn.className='palette-option';
    btn.dataset.palette=palette.id;
    btn.type='button';
    btn.title=palette.name;
    btn.setAttribute('aria-label', palette.name);
    const swatch=document.createElement('div');
    swatch.className='palette-swatch';
    palette.colors.forEach(color=>{
      const dot=document.createElement('span');
      dot.className='palette-dot';
      dot.style.background=color;
      swatch.appendChild(dot);
    });
    btn.appendChild(swatch);
    btn.addEventListener('click',()=>{
      applyPalette(palette.id,true);
      closePalettePanel();
    });
    palettePanel.appendChild(btn);
  });
  updatePaletteSelection();
}

function updatePaletteSelection(){
  if(!palettePanel) return;
  palettePanel.querySelectorAll('.palette-option').forEach(btn=>{
    btn.classList.toggle('active', btn.dataset.palette===currentPaletteId);
  });
}

function applyPalette(id, persist=false){
  const palette=PALETTES.find(p=>p.id===id) || PALETTES[0];
  currentPaletteId=palette.id;
  document.documentElement.style.setProperty('--block', palette.colors[0]);
  if(persist){
    try{ localStorage.setItem(STORAGE_KEYS.palette,currentPaletteId); }catch(err){}
  }
  tray=tray.map(piece=>piece?assignPieceColor(piece):piece);
  if(selected && typeof selected.idx==='number' && tray[selected.idx]){
    selected.color=tray[selected.idx].color;
  }
  updatePaletteSelection();
  updateBoardCells();
  renderTray();
}

function togglePalettePanel(){
  palettePanelOpen=!palettePanelOpen;
  if(palettePanel){
    palettePanel.classList.toggle('show', palettePanelOpen);
  }
}

function closePalettePanel(){
  palettePanelOpen=false;
  if(palettePanel){
    palettePanel.classList.remove('show');
  }
}

function loadSavedPalette(){
  let saved=null;
  try{
    saved=localStorage.getItem(STORAGE_KEYS.palette);
  }catch(err){
    saved=null;
  }
  applyPalette(saved || currentPaletteId, false);
}

function loadBestScore(){
  let saved=null;
  try{
    saved=localStorage.getItem(STORAGE_KEYS.best);
  }catch(err){
    saved=null;
  }
  const parsed=parseInt(saved,10);
  bestScore=Number.isFinite(parsed) && parsed>0 ? parsed : 0;
  updateBestScoreDisplay();
}

function updateBestScoreDisplay(){
  if(topScoreEl) topScoreEl.textContent=bestScore;
}

function freezeTopbar(){
  if(topbarEl) topbarEl.classList.add('frozen');
}
function unfreezeTopbar(){
  if(topbarEl) topbarEl.classList.remove('frozen');
}

function recordBestScore(){
  if(score>bestScore){
    bestScore=score;
    updateBestScoreDisplay();
    try{ localStorage.setItem(STORAGE_KEYS.best,String(bestScore)); }catch(err){}
  }
}

function hideGameOver(){
  if(gameOverEl) gameOverEl.classList.remove('show');
  unfreezeTopbar();
}

buildPalettePanel();
loadSavedPalette();
loadBestScore();

function buildBoard(){
  boardEl.innerHTML='';
  for(let i=0;i<BOARD*BOARD;i++){
    const d=document.createElement('div');
    d.className='cell';
    d.dataset.x=(i%BOARD);
    d.dataset.y=Math.floor(i/BOARD);
    d.addEventListener('pointerenter', previewHover);
    d.addEventListener('pointerleave', ()=>{ if(selected && !draggingPiece) clearPreviewAll(); });
    d.addEventListener('dragover', handleDragOver);
    d.addEventListener('drop', handleDrop);
    boardEl.appendChild(d);
  }
  const someCell=boardEl.firstElementChild;
  boardCellSize=Math.round(someCell.getBoundingClientRect().width);
}

function newGrid(){ grid=Array.from({length:BOARD},()=>Array(BOARD).fill(EMPTY)); updateBoardCells(); }
function dealPiece(){
  return assignPieceColor({shape: JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random()*SHAPES.length)]))});
}
function refillTray(force=false){
  if(!Array.isArray(tray) || tray.length!==3){
    tray=new Array(3).fill(null);
  }
  const needsRefill = force || tray.every(slot=>!slot);
  if(needsRefill){
    for(let i=0;i<tray.length;i++){
      tray[i]=dealPiece();
    }
  }
  selected=null;
  clearPreviewAll();
  clearPendingAnchor();
  renderTray();
  saveGameState();
}

function drawPiece(container,shape,{fullSize=false,color=null,skipSizing=false}={}){
  container.innerHTML='';
  const xs=shape.map(s=>s[0]), ys=shape.map(s=>s[1]);
  const w=Math.max(...xs)+1, h=Math.max(...ys)+1;
  const baseCell=boardCellSize || 32;
  const currentGap=boardGap || 6;
  const miniCell=Math.max(MIN_TRAY_CELL, Math.round(baseCell*TRAY_SCALE));
  const cellSize=fullSize ? baseCell : miniCell;
  const gap=fullSize ? currentGap : Math.max(MIN_TRAY_GAP, Math.round(currentGap*0.95));
  const fillColor=(color || document.documentElement.style.getPropertyValue('--block') || getComputedStyle(document.documentElement).getPropertyValue('--block') || '#57606A').trim();
  const width=(w*cellSize)+Math.max(0,w-1)*gap;
  const height=(h*cellSize)+Math.max(0,h-1)*gap;
  container.style.display='grid';
  container.style.width=width+'px';
  container.style.height=height+'px';
  container.style.gridTemplateColumns=`repeat(${w}, ${cellSize}px)`;
  container.style.gridTemplateRows=`repeat(${h}, ${cellSize}px)`;
  container.style.gap=gap+'px';
  const parentEl=container.parentElement;
  if(parentEl && parentEl!==document.body && !skipSizing){
    parentEl.style.minHeight=(height+20)+'px';
  }
  shape.forEach(([x,y])=>{
    const b=document.createElement('div'); b.className='b';
    b.dataset.cx=x;
    b.dataset.cy=y;
    b.style.gridColumn=(x+1);
    b.style.gridRow=(y+1);
    b.style.background=fillColor;
    container.appendChild(b);
  });
}

function createDragGhost(shape,color){
  const ghost=document.createElement('div');
  ghost.className='drag-ghost';
  ghost.style.padding='0';
  ghost.style.margin='0';
  ghost.style.background='transparent';
  document.body.appendChild(ghost);
  drawPiece(ghost,shape,{fullSize:true,color});
  return ghost;
}

function createPointerGhost(shape,color){
  removePointerGhost();
  pointerGhost=document.createElement('div');
  pointerGhost.className='pointer-ghost';
  document.body.appendChild(pointerGhost);
  drawPiece(pointerGhost,shape,{fullSize:true,color});
  return pointerGhost;
}

function getAnchorCenterOffsetPx(){
  const anchor=getSelectedAnchor();
  const cell=boardCellSize || 32;
  const gap=boardGap || 6;
  return {
    x:(anchor.dx||0)*(cell+gap) + cell/2,
    y:(anchor.dy||0)*(cell+gap) + cell/2
  };
}

function updatePointerGhostPosition(e){
  if(!pointerGhost) return;
  const anchorPoint=getAnchorPointFromEvent(e);
  const offset=getAnchorCenterOffsetPx();
  const left=anchorPoint.x - offset.x;
  const top=anchorPoint.y - offset.y;
  pointerGhost.style.transform=`translate(${left}px, ${top}px)`;
}

function removePointerGhost(){
  if(pointerGhost){
    pointerGhost.remove();
    pointerGhost=null;
  }
}

function renderTray(){
  trayEl.innerHTML='';
  tray.forEach((p,idx)=>{
    const card=document.createElement('div');
    const hasPiece=!!p;
    const isActive=hasPiece && selected && selected.idx===idx;
    const isDraggingActive=isActive && draggingPiece;
    card.className='piece'+(isActive?' selected':'')+(isDraggingActive?' dragging':'')+(hasPiece?'':' empty');
    if(hasPiece){
      card.setAttribute('draggable','true');
      card.addEventListener('pointerdown', e=>handlePiecePointerDown(e,idx));
      card.addEventListener('dragstart', e=>beginDrag(e,idx));
      card.addEventListener('dragend', finishDrag);
      const inner=document.createElement('div'); inner.className='piece-inner'; card.appendChild(inner);
      drawPiece(inner,p.shape,{fullSize:false,color:p.color});
      if(isActive && !draggingPiece){
        const overlay=document.createElement('div');
        overlay.className='piece-overlay';
        card.appendChild(overlay);
        drawPiece(overlay,p.shape,{fullSize:true,color:p.color, skipSizing:true});
      }
    }else{
      card.setAttribute('aria-hidden','true');
    }
    trayEl.appendChild(card);
  });
}

function handlePiecePointerDown(e,idx){
  if(!tray[idx]) return;
  rememberAnchor(e,idx);
  capturePointerAnchorOffset(e);
  if(e.pointerType==='mouse' || e.pointerType==='pen'){
    return;
  }
  if(isClearing || draggingPiece) return;
  e.preventDefault();
  startPointerDrag(e,idx);
}

function startPointerDrag(e,idx){
  const piece=tray[idx];
  if(!piece) return;
  const anchor = takeAnchorFromDrag(e,idx);
  selected={shape:piece.shape, idx, anchor, color:piece.color};
  setTimeout(()=>renderTray(),0);
  draggingPiece=true;
  pointerDragId=e.pointerId;
  pointerCaptureTarget=e.currentTarget;
  if(pointerCaptureTarget && pointerCaptureTarget.setPointerCapture){
    try{ pointerCaptureTarget.setPointerCapture(e.pointerId); }catch(err){}
  }
  pointerGhost=createPointerGhost(piece.shape,piece.color);
  boardEl.classList.add('dragging');
  window.addEventListener('pointermove', handlePointerMove);
  window.addEventListener('pointerup', handlePointerUp);
  window.addEventListener('pointercancel', handlePointerCancel);
  updatePointerPreview(e);
  updatePointerGhostPosition(e);
}

function handlePointerMove(e){
  if(e.pointerId!==pointerDragId) return;
  e.preventDefault();
  updatePointerPreview(e);
  updatePointerGhostPosition(e);
}

function handlePointerUp(e){
  if(e.pointerId!==pointerDragId) return;
  e.preventDefault();
  finalizePointerDrag(e);
}

function handlePointerCancel(e){
  if(e.pointerId!==pointerDragId) return;
  e.preventDefault();
  cancelPointerDrag();
}

function updatePointerPreview(e){
  const anchorPoint=getAnchorPointFromEvent(e);
  const cell=getCellFromCoords(anchorPoint.x, anchorPoint.y);
  if(cell){
    showPreviewAt(+cell.dataset.x, +cell.dataset.y);
  }else{
    clearPreviewAll();
  }
}

function finalizePointerDrag(e){
  cleanupPointerDragListeners();
  pointerDragId=null;
  const anchorPoint=getAnchorPointFromEvent(e);
  const cell=getCellFromCoords(anchorPoint.x, anchorPoint.y);
  let placed=false;
  if(cell){
    placed=attemptPlacement(+cell.dataset.x, +cell.dataset.y);
  }else if(currentPreview && currentPreview.origin){
    placed=attemptPlacement(null,null,currentPreview.origin);
  }
  if(!placed){
    finishDrag();
  }else{
    releaseDragUIState();
  }
}

function cancelPointerDrag(){
  cleanupPointerDragListeners();
  pointerDragId=null;
  finishDrag();
}

function cleanupPointerDragListeners(){
  window.removeEventListener('pointermove', handlePointerMove);
  window.removeEventListener('pointerup', handlePointerUp);
  window.removeEventListener('pointercancel', handlePointerCancel);
  releasePointerCapture();
}

function releasePointerCapture(){
  if(pointerCaptureTarget && pointerCaptureTarget.releasePointerCapture && pointerDragId!=null){
    try{ pointerCaptureTarget.releasePointerCapture(pointerDragId); }catch(err){}
  }
  pointerCaptureTarget=null;
}

function rememberAnchor(e,idx){
  const tile=e.target.closest('.b');
  if(tile){
    pendingAnchor={dx:+tile.dataset.cx, dy:+tile.dataset.cy};
    pendingAnchorIdx=idx;
    pendingAnchorRect=tile.getBoundingClientRect();
  }else{
    clearPendingAnchor();
  }
}

function clearPendingAnchor(){
  pendingAnchor=null;
  pendingAnchorIdx=null;
  pendingAnchorRect=null;
}

function takeAnchorFromDrag(e,idx){
  const pending = (pendingAnchorIdx===idx && pendingAnchor) ? pendingAnchor : null;
  clearPendingAnchor();
  const fromPoint = anchorFromPointer(e);
  return pending || fromPoint || ZERO_ANCHOR();
}

function anchorFromPointer(e){
  if(typeof e.clientX!=='number' || typeof e.clientY!=='number') return null;
  const el=document.elementFromPoint(e.clientX, e.clientY);
  const tile=el && el.closest('.b');
  if(tile && tile.dataset.cx!=null){
    return {dx:+tile.dataset.cx, dy:+tile.dataset.cy};
  }
  return null;
}

function capturePointerAnchorOffset(e){
  if(e && pendingAnchorRect){
    const cx=typeof e.clientX==='number' ? e.clientX : 0;
    const cy=typeof e.clientY==='number' ? e.clientY : 0;
    const centerX=pendingAnchorRect.left + pendingAnchorRect.width/2;
    const centerY=pendingAnchorRect.top + pendingAnchorRect.height/2;
    pointerAnchorOffset={
      x:cx-centerX,
      y:cy-centerY
    };
  }else{
    pointerAnchorOffset={x:0,y:0};
  }
}

function getAnchorPointFromEvent(e){
  const baseX=typeof e.clientX==='number' ? e.clientX : 0;
  const baseY=typeof e.clientY==='number' ? e.clientY : 0;
  const cell=boardCellSize || 32;
  const gap=boardGap || 6;
  const lift=Math.max((cell+gap)*2, 48);
  return {
    x:baseX - pointerAnchorOffset.x,
    y:baseY - pointerAnchorOffset.y - lift
  };
}

function getCellFromCoords(x,y){
  if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
  const clampedX=Math.max(0, Math.min(window.innerWidth-1, x));
  const clampedY=Math.max(0, Math.min(window.innerHeight-1, y));
  const el=document.elementFromPoint(clampedX, clampedY);
  return el && el.closest('.cell');
}

function beginDrag(e,idx){
  if(isClearing){ e.preventDefault(); return; }
  const piece=tray[idx];
  if(!piece) return;
  const anchor = takeAnchorFromDrag(e,idx);
  selected={shape:piece.shape, idx, anchor, color:piece.color};
  dragGhost=createDragGhost(piece.shape,piece.color);
  setTimeout(()=>renderTray(),0);
  draggingPiece=true;
  boardEl.classList.add('dragging');
  if(e.dataTransfer){
    if(dragGhost){
      const rect=dragGhost.getBoundingClientRect();
      e.dataTransfer.setDragImage(dragGhost, rect.width/2, rect.height/2);
    }
    e.dataTransfer.effectAllowed='move';
    e.dataTransfer.setData('text/plain', String(idx));
  }
}

function finishDrag(){
  releaseDragUIState();
  clearPreviewAll();
  selected=null;
  renderTray();
}

function releaseDragUIState(){
  boardEl.classList.remove('dragging');
  draggingPiece=false;
  releasePointerCapture();
  removePointerGhost();
  pointerAnchorOffset={x:0,y:0};
  if(dragGhost){
    dragGhost.remove();
    dragGhost=null;
  }
}

function updateBoardCells(){
  if(!grid) return;
  document.querySelectorAll('.cell').forEach(c=>{
    const x=+c.dataset.x, y=+c.dataset.y;
    const cellValue=grid[y][x];
    const isFilled = cellValue!==EMPTY;
    c.classList.toggle('filled', isFilled);
    c.classList.remove('preview');
    if(isFilled){
      c.style.setProperty('--cell-fill', cellValue);
      c.style.background=cellValue;
      c.style.boxShadow='none';
    }else{
      c.style.removeProperty('--cell-fill');
      c.style.background='';
      c.style.boxShadow='';
    }
  });
}

function canPlaceAt(x,y,shape){
  return shape.every(([dx,dy])=>{
    const cx=x+dx, cy=y+dy;
    return cx>=0 && cy>=0 && cx<BOARD && cy<BOARD && grid[cy][cx]===EMPTY;
  });
}

function placeAt(x,y,shape,color=null){
  const fillColor=color || pickPieceColor();
  shape.forEach(([dx,dy])=>{ grid[y+dy][x+dx]=fillColor; });
  score += shape.length; scoreEl.textContent=score;
  recordBestScore();
  updateBoardCells();
  clearLines();
}

function clearLines(){
  const rows=[], cols=[];
  for(let y=0;y<BOARD;y++) if(grid[y].every(v=>v!==EMPTY)) rows.push(y);
  for(let x=0;x<BOARD;x++){
    let ok=true;
    for(let y=0;y<BOARD;y++) if(grid[y][x]===EMPTY){ ok=false; break; }
    if(ok) cols.push(x);
  }
  if(!rows.length && !cols.length) return;

  isClearing=true;
  const coords=new Set();
  const rowSet=new Set(rows);
  const colSet=new Set(cols);
  const delayStepSeconds=CLEAR_DELAY_STEP_MS/1000;
  let pendingAnimations=0;
  let resolved=false;
  const finishClear=()=>{
    if(resolved) return;
    resolved=true;
    isClearing=false;
  };
  rows.forEach(y=>{ for(let x=0;x<BOARD;x++) coords.add(`${x},${y}`); });
  cols.forEach(x=>{ for(let y=0;y<BOARD;y++) coords.add(`${x},${y}`); });

  coords.forEach(key=>{
    const [cx,cy]=key.split(',').map(Number);
    grid[cy][cx]=EMPTY;
    const cell=document.querySelector(`.cell[data-x="${cx}"][data-y="${cy}"]`);
    if(cell){
      cell.classList.remove('filled');
      cell.classList.remove('preview');
      cell.style.background='';
      cell.style.removeProperty('--cell-fill');
      const rowDelay = rowSet.has(cy) ? cx*delayStepSeconds : 0;
      const colDelay = colSet.has(cx) ? cy*delayStepSeconds : 0;
      const delay = Math.max(rowDelay, colDelay);
      cell.style.setProperty('--clear-delay', `${delay}s`);
      cell.classList.add('clearing');
      pendingAnimations++;
      const handle=()=>{
        cell.classList.remove('clearing');
        cell.style.removeProperty('--clear-delay');
        if(--pendingAnimations===0) finishClear();
      };
      cell.addEventListener('animationend', handle, {once:true});
    }
  });

  score += (rows.length+cols.length)*10;
  scoreEl.textContent=score;
  if(pendingAnimations===0) finishClear();
}

function previewHover(e){
  showPreviewAt(+e.currentTarget.dataset.x, +e.currentTarget.dataset.y);
}

function showPreviewAt(x,y){
  if(!selected) return;
  const origin=findPlacementOrigin(x,y);
  clearPreviewAll();
  if(!origin) return;
  const {ox,oy}=origin;
  const shape=selected.shape;
  const cells=[];
  shape.forEach(([dx,dy])=>{
    const cell=document.querySelector(`.cell[data-x="${ox+dx}"][data-y="${oy+dy}"]`);
    if(cell){
      cell.classList.add('preview');
      cells.push(cell);
    }
  });
  currentPreview={origin, cells};
}

function clearPreviewAll(){
  if(currentPreview && currentPreview.cells){
    currentPreview.cells.forEach(cell=>cell.classList.remove('preview'));
  }else{
    document.querySelectorAll('.cell.preview').forEach(c=>c.classList.remove('preview'));
  }
  currentPreview=null;
}

function handleDragOver(e){
  if(!selected) return;
  e.preventDefault();
  if(e.dataTransfer) e.dataTransfer.dropEffect='move';
  const cell=e.currentTarget;
  showPreviewAt(+cell.dataset.x, +cell.dataset.y);
}

function handleDrop(e){
  if(!selected) return;
  e.preventDefault();
  e.stopPropagation();
  const cell=e.currentTarget;
  attemptPlacement(+cell.dataset.x, +cell.dataset.y);
}

boardEl.addEventListener('dragover', handleBoardDragOver);
boardEl.addEventListener('drop', handleBoardDrop);
boardEl.addEventListener('pointerleave', ()=>{ if(!draggingPiece) clearPreviewAll(); });

function handleBoardDragOver(e){
  if(!selected) return;
  e.preventDefault();
  if(e.dataTransfer) e.dataTransfer.dropEffect='move';
  const cell=e.target.closest('.cell');
  if(cell) showPreviewAt(+cell.dataset.x, +cell.dataset.y);
}

function handleBoardDrop(e){
  if(!selected) return;
  e.preventDefault();
  if(currentPreview && currentPreview.origin){
    attemptPlacement(null,null,currentPreview.origin);
  }else{
    const cell=e.target.closest('.cell');
    if(cell) attemptPlacement(+cell.dataset.x, +cell.dataset.y);
  }
}

function attemptPlacement(x,y,originOverride=null){
  if(!selected) return false;
  if(isClearing){ bumpBoard(); return false; }
  const piece=selected.shape;
  const idx=selected.idx;
  let origin=originOverride;
  if(!origin && Number.isFinite(x) && Number.isFinite(y)){
    origin=findPlacementOrigin(x,y);
  }
  if(!origin && currentPreview) origin=currentPreview.origin;
  if(!origin){
    bumpBoard();
    return false;
  }
  const {ox,oy}=origin;
  placeAt(ox,oy,piece, selected && selected.color ? selected.color : null);
  if(typeof idx==='number' && tray[idx]){
    tray[idx]=null;
  }
  selected=null;
  clearPreviewAll();
  if(tray.every(slot=>!slot)){
    refillTray();
  }else{
    renderTray();
  }
  saveGameState();
  checkGameOver();
  return true;
}

function bumpBoard(){
  /* no-op to keep board steady */
}

function checkGameOver(){
  const activePieces=tray.filter(Boolean);
  if(!activePieces.length) return;
  const anyFit = activePieces.some(p=>{
    for(let y=0;y<BOARD;y++){
      for(let x=0;x<BOARD;x++){
        if(canPlaceAt(x,y,p.shape)) return true;
      }
    }
    return false;
  });
  if(!anyFit){
    finalScoreEl.textContent=score;
    updateBestScoreDisplay();
    gameOverEl.classList.add('show');
    freezeTopbar();
    clearSavedGame();
  }
}

/* controls */
document.getElementById('resetBtn').onclick=()=>start(true);
document.getElementById('againBtn').onclick=()=>{ hideGameOver(); start(true); };
if(paletteBtn){
  paletteBtn.addEventListener('click', e=>{
    e.stopPropagation();
    togglePalettePanel();
  });
}
document.addEventListener('click', e=>{
  if(!palettePanelOpen) return;
  const target=e.target;
  if(palettePanel && !palettePanel.contains(target) && target!==paletteBtn && (!paletteBtn || !paletteBtn.contains(target))){
    closePalettePanel();
  }
});
window.addEventListener('keydown', e=>{
  if(e.key==='Escape'){
    closePalettePanel();
  }
});

/* boot */
function start(forceNew=false){
  closePalettePanel();
  hideGameOver();
  selected=null;
  isClearing=false;
  clearPreviewAll();
  boardEl.classList.remove('dragging');
  tray=new Array(3).fill(null);
  buildBoard();
  clearPendingAnchor();
  if(forceNew){
    clearSavedGame();
    score=0;
    scoreEl.textContent=score;
    newGrid();
    refillTray(true);
  }else{
    const restored=restoreSavedGame();
    if(!restored){
      score=0;
      scoreEl.textContent=score;
      newGrid();
      refillTray(true);
    }
  }
  scheduleResponsiveSize();
}
start();

window.addEventListener('resize', scheduleResponsiveSize);
window.addEventListener('orientationchange', scheduleResponsiveSize);

if('serviceWorker' in navigator){
  window.addEventListener('load', ()=>{
    navigator.serviceWorker.register('./sw.js').catch(err=>{
      console.warn('Service worker registration failed', err);
    });
  });
}
</script>
</body>
</html>
